# Dart - язык программирования

## Важные концепции

- Все что можно поместить в переменную является объектом, каждый объект является экземпляром класса. Числа, функции и даже `null` явлеяется объектом. Все объекты наследуются от класса `Object`.
- Хотя Dart строго типизирован, аннотации типов необязательны, поскольку Dart может определять типы. Если нужно явно сказать, что никакого типа не ожидается, используется специальный тип `dynamic`.
- Dart поддерживает обобщения, такие как `List<int>` или `List<dynamic>`.
- Dart поддерживает функции верхнего уровня (такие как `main()`), также функции связанные с классами или объектами (статические или методы объектов). Можно также создавать функции внутри функций (вложенные или локальные)
- Dart поддерживает переменные верхнего уровня (глобальные), также как и связанные с классами или объектами. Переменные состояния также иногда называют полями или свойствами.
- Идендификатор, начинающийся со знака подчеркивания (_) является приватным.
- Идендификаторы могут начинаться со знака подчеркивания с последующим написанием любых букв и цифр.
- В Dart есть как выражения, так и операторы.(`condition ? expr1 : expr2` - `if() { } else { }`)
- Инструменты Dart могут сообщить о 2-х типах проблем: предупреждения (warnings) и ошибки (errors).

## Переменные

Пример объявления и инициализации переменной:

```dart
var name = 'Bob';
```

Переменная - ссылка на объект. Переменная `name` содержит ссылку на объект типа `String` со значением "Bob".

Если объект не должен содержать значения определенного класса, то его можно описать типом `Object` или `dynamic`.

```dart
dynamic name = 'Bob';
```

Можно также явно указать тип переменной при её объявлении:

```dart
String name = 'Bob';
```

### Значение по-умолчанию

Не инициализированные переменные имеют значение `null`. Даже переменные числового типа инициализируются null-ом. Потому что в Dart всё является объектами.

```dart
int lineCount;
assert(lineCount == null);
```

> **Примечание**: Окончательный код игнорирует `assert()`. Во время дебагинга `assert(выражение)` выбрасывает ошибку, если результат выражения ложный.

### Final и const

Если значение переменной не должно меняться, то нужно использовать `final` или `const` вместо `var` . `final` - значение объявляется только один раз; `const` - постоянная времени компиляции. `final` верхнего уровня или переменная класса инициализируется во время первого использования.

>  **Примечание**: Переменная экземляра может быть `final` но не `const`. Final-объект должен быть инициализирован до начала тела конструктора - в месте описания параметров конструктора или в [листе инициализации](https://dart.dev/guides/language/language-tour#initializer-list) коструктора.

```dart
final name = 'Bob'; // без анотации типа
final String nickname = 'Bobby';
```

Если `const` находится в классе, то она помечается как статическая (`static`). В месте где объявляется константа значение устанавливается из таких же констант как цифровые или строчные литералы, другие константы, или результаты арифметических операций между числовыми константами.

```dart
const bar = 100000;
const double atm = 1.01325 * bar;
```

Ключевое слово `const` используется не только для объявления констант. Его можно использовать для создания константных значений при объявлении конструкторов. Любые переменные могут иметь константное значение.

```dart
var foo = const [];
final var = const [];
const baz = []; // равнозначно const []
```

Значение, которое не имеет анотацию `final` или `const` можно изменять, даже если его значение было объявлено с использование `const`:

```dart
foo = [1, 2, 3]; // было const []
```

### Встроеные типы

Dart поддерживает следующие типы:

- числа
- строки
- логический тип
- списки
- наборы
- словари
- руны (для выражения символо юникода в строке)
- символы

Некоторые из встроенных типов имеют свои конструкторы.

#### Числа

[int](https://api.dart.dev/stable/dart-core/int-class.html)

Целочисленные значения не больше 64 бит в зависимости от платформы. В Dart VM значения могут быть от -2<sup>63</sup> до 2<sup>63</sup> - 1. При компиляции в JavaScript допустимые значения -2<sup>53</sup> до 2<sup>53</sup> - 1.

[double](https://api.dart.dev/stable/dart-core/double-class.html)

Дробные числа двойной точности 64 бит.

`int` и `double` являются подтипами [num](https://api.dart.dev/stable/dart-core/num-class.html)

```dart
var x = 1; // int
var hex = 0xDEADBEEF; // int
var y = 1.1; // double
var exponents = 1.4e5; // double
double z = 1; // integer 1 конвертируется в double 1.0
```

Строки можно конвертировать в числа  и наоборот:

```dart
// String -> int
var one = int.parse('1');
// String -> double
var onePointOne = double.parse('1.1');
// int -> String
String oneAsString = 1.toString();
// double -> String
String piAsString = 3.14159.toStringAsFixed(2); // '3.14'
```

Для целых чисел есть побитовые операторы сдвига ( `<<` , `>>` ), и ( `&`), или ( `|` ):

```dart
3 << 1 // 0011 << 1 -> 0110
3 >> 1 // 0011 >> 1 -> 0001
3 | 4  // 0011 | 0100 -> 0111
```

#### Строки

Строки в Dart являются последовательностью из символов UTF-16. Для их создания можно использовать двойные или одинарные ковычки.

```dart
var s1 = 'Single quotes work well for string literals.';
var s2 = "Double quotes work just as well.";
var s3 = 'It\'s easy to escape the string delimiter.';
var s4 = "It's even easier to use the other delimiter.";
```

Возможно вставлять выражение в строку используя `${выражение}`. Также можно вставлять идентификатор переменной, тогда {} можно опустить. Чтобы получить строку соответсвующую объекту можно вызвать метод `toString()`.

```dart
var s = 'интерполяция строк';

assert('В Dart есть $s, которая очень удобна.' ==
    'В Dart есть интерполяция строк, ' +
        'которая очень удобна.');
assert('${s.toUpperCase()} очень удобна!' ==
        'ИНТЕРПОЛЯЦИЯ СТРОК очень удобна!');
```

Сцепить строки можно при помощи оператора `+`:

```dart
var s1 = 'Оператор + ' + 'работает хорошо.';
var s2 = 'Конкатенация строк работает даже если'
    	  "строка разорвется.";
```

Для создание многострочной записи используются тройные одинарные или двойные ковычки:

```dart
var s1 = '''
Вы можете создать
многострочню запись вот так.
''';

var s2 = """Это также
многострочная запись.""";
```

Можно создать строку с игнорированием escape-последовательностей и спецсимволов:

```dart
var s = r'В raw-строке даже \n не получает особого отношения';
```

Строковой литерал является константой времени компиляции если он состоит также из выражений констант времени компиляции таких как null или числа, строки или логические переменные.

```dart
// Это работает в строковой константе
const aConstNum = 0;
const aConstBool = true;
const aConstString = 'строковая константа';

// Это не работает в строковой константе
var aNum = 0;
var aBool = true;
var aString = 'строка';
const aConstList = [1, 2, 3];

const validConstString = '$aConstNum $aConstBool $aConstString';
// const invalidConstString = '$aNum $aBool $aString $aConstList';
```

#### Логический тип

Логический тип имеет только два объекта `true` и `false`, которые являются константами времени компиляции.

В Dart не возможно использовать не булево выражение в `if` или `assert`. Вместо этого нужно явно проверять значение переменной:

```dart
// Проверка пуста ли строка
var fullName = '';
assert(fullName.isEmpty);

// Проверка на ноль
var hitPoints = 0;
assert(hitPoints <= 0);

// Проверка на null
var unicorn;
assert(unicorn == null);

// Проверка на NaN.
var iMeantToDoThis = 0 / 0;
assert(iMeantToDoThis.isNaN);
```

#### Списки 

[List](https://api.dart.dev/stable/dart-core/List-class.html)

В Dart массивы - это объекты `List`.

```dart
var list = [1, 2, 3];
```

> **Примечание**: `list` имеет тип `List<int>`. Если попробовать добавить в этот список не целочисленное значение, то это приведет к ошибке.

Можно добавить запятую после последнего элемента списка. Эта запятая не будет влиять на всю коллекцию, но это поможет избежать ошибок копирования.

```dart
var list = [
  'Car',
  'Boat',
  'Plane',
];
```

Нумерация в списках начинается с нуля.

```dart
var list = [1, 2, 3];
assert(list.length == 3);
assert(list[1] == 2);

list[1] = 1;
assert(list[1] == 1);
```

Чтобы создать список, который является константой времени компиляции, нужно добавить `const` до списочного литерала:

```dart
var constantList = const [1, 2, 3];
// constantList[1] = 1; // Эта строка вызовет ошибку.
```

Dart 2.3 появиля spread-оператор (`...`) и spread-оператор с нулевым значением (`...?`), которые обеспечивают краткий способ вставки нескольких значений в коллекцию.

```dart
var list = [1, 2, 3];
var list2 = [0, ...list];
assert(list2.length == 4);
```

Если значение выражения справа от spread-оператора может быть null, то нужно использовать spread-оператор с нулевым значением (`...?`)

```dart
var list;
var list2 = [0, ...?list];
assert(list2.length == 1);
```

При создании списков можно использовать условные конструкции и циклы:

```dart
var nav = [
  'Home',
  'Furniture',
  'Plants',
  if (promoActive) 'Outlet'
];

var listOfInts = [1, 2, 3];
var listOfStrings = [
  '#0',
  for (var i in listOfInts) '#$i'
];
```

#### Наборы

[Set](https://api.dart.dev/stable/dart-core/Set-class.html)

Набор в Dart это неупорядоченная коллекция уникальных значений.

```dart
// halogens имеет тип Set<String>
var halogens = {'fluorine', 'chlorine', 'bromine', 'iodine', 'astatine'};
```

Для создания набора можно использовать пустую `{}`, которой предшевствует тип, или назначить `{}` переменной типа `Set`:

```dart
var names = <String>{};
Set<String> something = {}; 
// var names = {}; // компилятор не поймет какого типа набор
```

>  **Примечание**: Поскольку словари (`Map`) в Dart появились раньше наборов, то если забыть анотацию к `{}`, то для переменной создастся объект типа `Map<dynamic, dynamic>`

Для добавление элементов к существующему набору используются `add()` или `addAll()` методы:

```dart
var elements = <String>{};
elements.add('fluorine');
elements.addAll(halogens);
```

Для получения количества элементов в наборе используется `.length`:

```dart
assert(elements.length == 5);
```

Чтобы создать набор, который является константой времени компиляци, нужно добавлять `const` до установки литералов:

```dart
final constantSet = const {
  'fluorine',
  'chlorine',
  'bromine',
  'iodine',
  'astatine',
};
// constantSet.add('helium'); // Эта строка содержит ошибку.
```

Наборы также поддерживают spread-оператор (`...`), nullspread-оператор (`...?`), условные конструкции (`if`) и циклы (`for`), также как и списки.

#### Словари

[Map](https://api.dart.dev/stable/dart-core/Map-class.html)

Словари состоят из ключей и значений. И ключи, и значения могут быть объектами любого типа. Ключ является уникальным, а значение может встречаться в словаре сколько угодно раз.

```dart
var gifts = {
  // Ключ:   Значение
  'first': 'partridge',
  'second': 'turtledoves',
  'fifth': 'golden rings'
};

var nobleGases = {
  2: 'helium',
  10: 'neon',
  18: 'argon',
};
```

Словари можно создать и инициализировать по другому:

```dart
var gifts = Map();
gifts['first'] = 'partridge';
gifts['second'] = 'turtledoves';
gifts['fifth'] = 'golden rings';

var nobleGases = Map();
nobleGases[2] = 'helium';
nobleGases[10] = 'neon';
nobleGases[18] = 'argon';
```

> **Примечение**: словарь можно создать и так `new Map()`, но слово `new` в Dart не обязательно.

```dart
// инициализация словаря
var gifts = {'first': 'partridge'};
// добавление новой пары ключ-значение
gifts['fourth'] = 'calling birds'; 
// получение значения из словаря по ключу
assert(gifts['first'] == 'partridge');
// проверка имеется ли ключ в словаре
assert(gifts['fifth'] == null);
// количество пар в словаре
assert(gifts.length == 2);
```

Словарь можно создать как константу времени компиляции при помощи `const`:

```dart
final constantMap = const {
  2: 'helium',
  10: 'neon',
  18: 'argon',
};

// constantMap[2] = 'Helium'; // Эта строка вызовет ошибку.
```

Словари поддерживают spread-оператор (`...`), nullspread-оператор (`...?`), условные конструкции (`if`) и циклы (`for`).

#### Руны и графемы

[Runes](https://api.dart.dev/stable/2.10.4/dart-core/Runes-class.html)

В Dart руны раскрывают кодовые точки Unicode строки.

Юникод определяет уникальное числовое значение для каждой буквы, цифры и символа, используемых во всех мировых системах письма. Поскольку строка Dart представляет собой последовательность кодовых единиц UTF-16, для выражения кодовых точек Unicode внутри строки требуется специальный синтаксис. Обычный способ обозначения кодовой точки Unicode - `\uXXXX`, где `XXXX` - 4-значное шестнадцатеричное значение. Например, символ сердца (`♥`) - `\u2665`. Чтобы указать более или менее 4 шестнадцатеричных цифр, заключите значение в фигурные скобки. Например, смеющийся смайлик (`😆`) - это `\u{1f606}`.

Если нужно прочитать или записать отдельные символы Unicode, нужно использовать метод получения символов, определенный в `String` пакет символов. Возвращенный объект `Characters` представляет собой строку как последовательность графем.

```dart
import 'package:characters/characters.dart';
...
var hi = 'Hi 🇩🇰';
print(hi);
print('The end of the string: ${hi.substring(hi.length - 1)}');
print('The last character: ${hi.characters.last}\n');
```

Результат:

```
$ dart bin/main.dart
Hi 🇩🇰
The end of the string: ???
The last character: 🇩🇰
```

#### Символы

[Symbol](https://api.dart.dev/stable/2.10.4/dart-core/Symbol-class.html)

Объект `Symbol` представляет собой оператор или идентификатор, объявленный в программе Dart. Возможно, вам никогда не понадобится использовать символы, но они бесценны для API, которые ссылаются на идентификаторы по имени, потому что минификация изменяет имена идентификаторов, но не символы идентификаторов.

Чтобы получить символ для идентификатора, используется литерал символа, который представляет собой просто `#`, за которым следует идентификатор:

```dart
#radix
#bar
```

## Функции

Dart - настоящий объектно-ориентированный язык, поэтому даже функции являются объектами и имеют тип [Function](https://api.dart.dev/stable/dart-core/Function-class.html). Это означает, что функции могут быть присвоены переменным или переданы в качестве аргументов другим функциям. Можно вызвать экземпляр класса Dart, как если бы это была функция.

Вот пример реализации функции:

```dart
bool isNoble(int atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}
```

Хотя рекомендуется использовать аннотации типов для общедоступных API, функция по-прежнему работает, если опустить типы

```dart
isNoble(atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}
```

Для функций, содержащих только одно выражение, можно использовать сокращенный синтаксис:

```dart
bool isNoble(int atomicNumber) => _nobleGases[atomicNumber] != null;
```

Синтаксис `=> expr` является сокращением для `{return expr;}`. Обозначение `=>` иногда называют синтаксисом *стрелки*.

> **Примечание**: Между стрелкой `=>` и точкой с запятой `;` может быть только выражение, но не оператор. Например, вы не можете поместить туда оператор `if`, но можете использовать условное выражение `expression ? true : false;`.

### Параметры

Функция может иметь любое количество требуемых *позиционных* параметров. За ними могут следовать *именованные* параметры или *необязательные* позиционные параметры (но не оба сразу).

> **Примечание**: Некоторые API - особенно конструкторы виджетов [Flutter](https://flutter.dev/) - используют только именованные параметры, даже если параметры являются обязательными. 

Можно использовать [конечные запятые](https://dart.dev/guides/language/language-tour#trailing-comma) при передаче аргументов функции или при определении параметров функции.

#### Именнованные параметры

Именованные параметры являются необязательными, если они специально не отмечены как обязательные. 

При вызове функции вы можете указать именованные параметры, используя `paramName: value`. Например:

```dart
enableFlags(bold: true, hidden: false);
```

При определении функции используйте `{param1, param2, …}`, чтобы указать именованные параметры:

```dart
/// Устанавливает флаги [bold] и [hidden] ...
void enableFlags({bool bold, bool hidden}) {...}
```

Хотя именованные параметры являются своего рода необязательными параметрами, вы можете аннотировать их с помощью `@required`, чтобы указать, что параметр является обязательным - что пользователи должны указать значение для параметра. Например:

```dart
const Scrollbar({Key key, @required Widget child})
```

Если кто-то пытается создать `Scrollbar` без указания `child`, анализатор сообщает о проблеме.

Чтобы использовать аннотацию `@required`  необходимо импортировать пакет: `meta/meta.dart`.

#### Необязательные позиционные параметры

Заключение набора параметров функции в `[]` отмечает их как необязательные позиционные параметры:

```dart
String say(String from, String msg, [String device]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  return result;
}
```

Вот пример вызова этой функции без необязательного параметра:

```dart
assert(say('Bob', 'Howdy') == 'Bob says Howdy');
```

А вот пример вызова этой функции с третьим параметром:

```dart
assert(say('Bob', 'Howdy', 'smoke signal') ==
    'Bob says Howdy with a smoke signal');
```

#### Значения параметров по умолчанию

Функция может использовать `=` для определения значений по умолчанию как для именованных, так и для позиционных параметров. Значения по умолчанию должны быть константами времени компиляции. Если значение по умолчанию не указано, значение по умолчанию - `null`.

Вот пример установки значений по умолчанию для названных параметров:

```dart
/// Устанавливает флаги [bold] и [hidden] ...
void enableFlags({bool bold = false, bool hidden = false}) {...}

// bold будет true; hidden будет false.
enableFlags(bold: true);
```

> **Примечание**: старый код может использовать двоеточие `:` вместо `=` для установки значений по умолчанию для именованных параметров. Причина в том, что изначально поддерживалось только `:` для именованных параметров. Эта поддержка может быть устаревшей, поэтому мы рекомендуем использовать `=` для указания значений по умолчанию.

В следующем примере показано, как установить значения по умолчанию для позиционных параметров:

```dart
String say(String from, String msg,
    [String device = 'carrier pigeon']) {
  var result = '$from says $msg with a $device';
  return result;
}

assert(say('Bob', 'Howdy') ==
    'Bob says Howdy with a carrier pigeon');
```

Можно передавать списки или словари в качестве значений по умолчанию. В следующем примере определяется функция `doStuff()`, которая определяет список по умолчанию для параметра `list` и словарь по умолчанию для параметра `gifts`.

```dart
void doStuff(
    {List<int> list = const [1, 2, 3],
    Map<String, String> gifts = const {
      'first': 'paper',
      'second': 'cotton',
      'third': 'leather'
    }}) {
  print('list:  $list');
  print('gifts: $gifts');
}
```

### Функция main()

Каждое приложение должно иметь функцию верхнего уровня `main()`, которая служит точкой входа в приложение. 

Функция `main()` возвращает `void` и имеет необязательный параметр `List<String>` для аргументов.

Вот пример функции `main()` для веб-приложения:

```dart
void main() {
  querySelector('#sample_text_id')
    ..text = 'Click me!'
    ..onClick.listen(reverseText);
}
```

> **Примечание**: Синтаксис `..` в предыдущем коде называется каскадом. С помощью каскадов можно выполнять несколько операций с элементами одного объекта.

Вот пример функции `main()` для приложения командной строки, которое принимает аргументы:

```dart
// Приложение запускается следующим образом: dart args.dart 1 test
void main(List<String> arguments) {
  print(arguments);

  assert(arguments.length == 2);
  assert(int.parse(arguments[0]) == 1);
  assert(arguments[1] == 'test');
}
```

Можно использовать библиотеку [args](https://pub.dev/packages/args) для определения и анализа аргументов командной строки.

### Функции как объекты класса

Можно передать функцию в качестве параметра другой функции. Например:

```dart
void printElement(int element) {
  print(element);
}

var list = [1, 2, 3];

// Передача printElement в качестве параметра.
list.forEach(printElement);
```

Также можно присвоить переменной функцию, например:

```dart
var loudify = (msg) => '!!! ${msg.toUpperCase()} !!!';
assert(loudify('hello') == '!!! HELLO !!!');
```

В этом примере используется анонимная функция.

### Анонимные функции

Большинство функций имеют имена, например `main()` или `printElement()`. Также можно создать безымянную функцию, называемую *анонимной функцией*, или иногда *лямбда-выражением* или *замыканием*. Можно назначить анонимную функцию переменной, чтобы, например, добавить или удалить ее из коллекции.

Анонимная функция похожа на именованную функцию - ноль или более параметров, разделенных запятыми, и необязательные аннотации типов в круглых скобках.

Следующий блок кода содержит тело функции:

```
([[Type] param1[, …]]) {
  codeBlock;
};
```

В следующем примере определяется анонимная функция с нетипизированным параметром `item`. Функция, вызываемая для каждого элемента в списке, печатает строку, которая включает значение по указанному индексу.

```dart
var list = ['apples', 'bananas', 'oranges'];
list.forEach((item) {
  print('${list.indexOf(item)}: $item');
});
```

Если функция содержит только один оператор, можно сократить его, используя обозначения стрелок.

```dart
list.forEach(
    (item) => print('${list.indexOf(item)}: $item')
);
```

### Лексическая область видимости

Dart - это язык с лексической областью видимости. Это означает, что область видимости переменных определяется статически, просто компоновкой кода. Можно «проследить за фигурными скобками», чтобы увидеть, входит ли переменная в область видимости.

Вот пример вложенных функций с переменными на каждом уровне области видимости:

```dart
bool topLevel = true;

void main() {
  var insideMain = true;

  void myFunction() {
    var insideFunction = true;

    void nestedFunction() {
      var insideNestedFunction = true;

      assert(topLevel);
      assert(insideMain);
      assert(insideFunction);
      assert(insideNestedFunction);
    }
  }
}
```

### Лексические замыкания

*Замыкание* - это объект функции, который имеет доступ к переменным в своей лексической области видимости, даже если функция используется за пределами своей исходной области видимости.

Функции могут закрывать переменные, определенные в окружающих областях. В следующем примере `makeAdder()` захватывает переменную `addBy`. Куда бы ни отправилась возвращаемая функция, она запоминает `addBy`.

```dart
/// Возвращает функцию, которая добавляет [addBy] в
/// аргумент функции.
Function makeAdder(int addBy) {
  return (int i) => addBy + i;
}

void main() {
  // Создание функции, которая добавляет 2.
  var add2 = makeAdder(2);

  // Создание функции, которая добавляет 4.
  var add4 = makeAdder(4);

  assert(add2(3) == 5);
  assert(add4(3) == 7);
}
```

### Проверка функций на равенство

Вот пример тестирования функций верхнего уровня, статических методов и методов экземпляра на равенство:

```dart
void foo() {} // Функция верхнего уровня

class A {
  static void bar() {} // Статический метод
  void baz() {} // Метод экземпляра
}

void main() {
  var x;

  // Сравнение функций верхнего уровня.
  x = foo;
  assert(foo == x);

  // Сравнение статический методов
  x = A.bar;
  assert(A.bar == x);

  // Сравнение экземпляров метода
  var v = A(); // Экземпляр #1 класса A
  var w = A(); // Экземпляр #2 класса A
  var y = w;
  x = w.baz;

  // Эти замыкания относятся к одному и тому же экземпляру (#2),
  // так что они равны.
  assert(y.baz == x);

  // Эти замыкания относятся к разным экземплярам,
  // значит, они неравны.
  assert(v.baz != w.baz);
}
```

### Возвращаемые значения

Все функции возвращают значение. Если возвращаемое значение не указано, то оператор `return null;` неявно добавляется к телу функции.

```dart
foo() {}

assert(foo() == null);
```

## Операторы

Dart поддерживает операторы, указанные в следующей таблице. Операторы можно  реализовать как члены класса.

| Описание                  | Операторы                                                    |
| ------------------------- | ------------------------------------------------------------ |
| унарный постфикс          | `expr++`  `expr--`  `()`  `[]`  `.`  `?.`                    |
| унарный префикс           | `-expr`  `!expr`  `~expr`  `++expr`  `--expr`   `await expr` |
| мультипликативные         | `*`  `/`  `%` `~/`                                           |
| добавочные                | `+`  `-`                                                     |
| сдвиг                     | `<<`  `>>`  `>>>`                                            |
| побитовое И               | `&`                                                          |
| побитовый XOR             | `^`                                                          |
| побитовое ИЛИ             | `|`                                                          |
| отношение и проверка типа | `>=`  `>`  `<=`  `<`  `as`  `is`  `is!`                      |
| равенство                 | `==`  `!=`                                                   |
| логическое И              | `&&`                                                         |
| логическое ИЛИ            | `||`                                                         |
| проверка на null          | `??`                                                         |
| условный                  | `expr1 ? expr2 : expr3`                                      |
| каскад                    | `..`                                                         |
| присваивание              | `=`  `*=`  `/=`  `+=`  `-=`  `&=`  `^=`  *и т.д.*            |

> **Предупреждение**: приоритет оператора - это приблизительное поведение парсера Dart. Чтобы получить точные ответы, обратитесь к грамматике в [спецификации языка Dart](https://dart.dev/guides/language/spec).

Используя операторы, создаются выражения. Вот несколько примеров операторных выражений:

```dart
a++
a + b
a = b
a == b
c ? a : b
a is T
```

В таблице операторов каждый оператор имеет более высокий приоритет, чем операторы в следующих за ним строках. Например, мультипликативный оператор `%` имеет более высокий приоритет, чем (и, следовательно, выполняется раньше) оператор равенства `==`, который имеет более высокий приоритет, чем логический оператор И `&&`. Этот приоритет означает, что следующие две строки кода выполняются одинаково:

```dart
// Круглые скобки улучшают читабельность.
if ((n % i == 0) && (d % i == 0)) ...

// Труднее читать, но равноценно.
if (n % i == 0 && d % i == 0) ...
```

> **Предупреждение**: для операторов, которые принимают два операнда, крайний левый операнд определяет, какой метод используется. Например, если у вас есть объект `Vector` и объект `Point`, то `aVector + aPoint` использует сложение `Vector` `+`.

### Арифметические операторы

Dart поддерживает обычные арифметические операторы, как показано в следующей таблице.

| Оператор | Значение                                                     |
| -------- | ------------------------------------------------------------ |
| `+`      | Сложение                                                     |
| `-`      | Вычитание                                                    |
| `-expr`  | Унарный минус, также известный как отрицание (поменять знак выражения) |
| `*`      | Умножение                                                    |
| `/`      | Деление                                                      |
| `~/`     | Деление нацело                                               |
| `%`      | Остаток от деления нацело                                    |

Примеры:

```dart
assert(2 + 3 == 5);
assert(2 - 3 == -1);
assert(2 * 3 == 6);
assert(5 / 2 == 2.5); // Результат double
assert(5 ~/ 2 == 2); // Результат int
assert(5 % 2 == 1); // Остаток

assert('5/2 = ${5 ~/ 2} r ${5 % 2}' == '5/2 = 2 r 1');
```

Dart также поддерживает как префиксные, так и постфиксные операторы увеличения и уменьшения.

| Оператор | Значение                                       |
| -------- | ---------------------------------------------- |
| `++var`  | `var = var + 1` (значение выражения `var + 1`) |
| `var++`  | `var = var + 1` (значение выражения `var`)     |
| `--var`  | `var = var - 1` (значение выражения `var - 1`) |
| `var--`  | `var = var - 1` (значение выражения `var`)     |

Примеры:

```dart
var a, b;

a = 0;
b = ++a; // Инкремент a, после b получает его значение.
assert(a == b); // 1 == 1

a = 0;
b = a++; // Инкремент a ПОСЛЕ того как b получает его значение.
assert(a != b); // 1 != 0

a = 0;
b = --a; // Декремент a, после b получает его значение.
assert(a == b); // -1 == -1

a = 0;
b = a--; // Декремент a ПОСЛЕ того как b получает его значение.
assert(a != b); // -1 != 0
```

### Операторы равенства и отношения

В следующей таблице перечислены значения операторов равенства и отношения.

| Оператор | Значение         |
| -------- | ---------------- |
| `==`     | равно            |
| `!=`     | не равно         |
| `>`      | больше           |
| `<`      | меньше           |
| `>=`     | больше или равно |
| `<=`     | меньше или равно |

Чтобы проверить, представляют ли два объекта `x` и `y` одно и то же, используется оператор `==`. (В редком случае, когда нужно знать, являются ли два объекта одним и тем же объектом, вместо него используется функция [identify ()](https://api.dart.dev/stable/dart-core/identical.html)) Вот как работает оператор `==`:

1. Если `x` или `y` равны `null`, вернуть истина, если оба равны `null`, и ложь, если только один из них равен `null`.
2. Вернуть результат вызова метода `x. == (y)`. (Такие операторы, как `==`, являются методами, которые вызываются для их первого операнда. )

### Операторы проверки типа

Операторы `as`, `is` и `is!` удобны для проверки типов во время выполнения.

| Оператор | Значение                                                     |
| -------- | ------------------------------------------------------------ |
| `as`     | Приведение типов (также используется для указания префиксов библиотеки) |
| `is`     | Истина, если объект имеет указанный тип                      |
| `is!`    | Ложь, если объект имеет указанный тип                        |

Результат `obj is T` истина, если `obj` реализует интерфейс, указанный в `T`. Например, `obj is Object` всегда истинно.

Используйте оператор `as` для приведения объекта к определенному типу тогда и только тогда, когда вы уверены, что объект относится к этому типу. Пример:

```dart
(emp as Person).firstName = 'Bob';
```

Если вы не уверены, что объект относится к типу `T`, используйте `is T` для проверки типа перед использованием объекта.

```dart
if (emp is Person) {
  // Проверка типа
  emp.firstName = 'Bob';
}
```

> **Примечание**: Код не эквивалентен. Если `emp` имеет значение `null ` или не является `Person`, то в первом примере выдается исключение; второй ничего не сделает.

### Операторы присваивания

Значения можно присваивать с помощью оператора `=`.  Чтобы присвоить значение переменной только если она равна `null` используется оператор `??=`.

```dart
// Присвоить значение a
a = value;
// Присвоить значение b если b равно null; иначе, b остается прежним
b ??= value;
```

Операторы составного присваивания, такие как `+=`, объединяют операцию с присваиванием.

`=` `–=` `/=` `%=` `>>=` `^=` `+=` `*=` `~/=` `<<=` `&=` `|=`

Вот как работают составные операторы присваивания:

|                         | Составное присвиавание | Эквивалентное выражение |
| ----------------------- | ---------------------- | ----------------------- |
| **Для оператора *op*:** | `a op= b`              | `a = a op b`            |
| **Пример:**             | `a += b`               | `a = a + b`             |

В следующем примере используются операторы присваивания и составного присваивания:

```dart
var a = 2; // Присвоить с помощью =
a *= 3; // Умножить и присвоить: a = a * 3
assert(a == 6);
```

### Логические операторы

Можно инвертировать или комбинировать логические выражения, используя логические операторы.

| Operator | Meaning                                                      |
| -------- | ------------------------------------------------------------ |
| `!expr`  | инвертирует следующее выражение (изменяет истина на ложь и наоборот) |
| `||`   | логическое И                                                 |
| `&&`     | логическое ИЛИ                                               |

Вот пример использования логических операторов:

```dart
if (!done && (col == 0 || col == 3)) {
  // ...Сделать что-то...
}
```

### Побитовые операторы и операторы сдвига

В Dart можно манипулировать отдельными битами чисел. Обычно эти побитовые операторы и операторы сдвига используются с целыми числами.

| Оператор | Значение                                                     |
| -------- | ------------------------------------------------------------ |
| `&`      | И                                                            |
| `|`      | ИЛИ                                                          |
| `^`      | Исключающее ИЛИ                                              |
| `~expr`  | Унарное побитовое дополнение (0s становится 1s; 1s становится 0s) |
| `<<`     | Сдвиг влево                                                  |
| `>>`     | Сдвиг вправо                                                 |

Вот пример использования побитовых операторов и операторов сдвига:

```dart
final value = 0x22;
final bitmask = 0x0f;

assert((value & bitmask) == 0x02); // И
assert((value & ~bitmask) == 0x20); // И НЕ
assert((value | bitmask) == 0x2f); // ИЛИ
assert((value ^ bitmask) == 0x2d); // Исключающее ИЛИ
assert((value << 4) == 0x220); // Сдвиг влево
assert((value >> 4) == 0x02); // Сдвиг вправо
```

### Условные выражения

В Dart есть два оператора, которые позволяют кратко описывать выражения, которые в противном случае могли бы потребовать операторов `if-else`:

`condition ? expr1 : expr2`

Если `condition` истинно, вычисляет `expr1` (и возвращает его значение); в противном случае вычисляет и возвращает значение `expr2`.

`expr1 ?? expr2`

Если `expr1` не равно нулю, возвращает его значение; в противном случае вычисляет и возвращает значение `expr2`.

Если нужно присвоить значение на основе логического выражения используется `?:`.

```dart
var visibility = isPublic ? 'public' : 'private';
```

Если логическое выражение проверяется на `null` используется `??`.

```dart
// Немного более длинная версия использует оператор ?: .
String playerName(String name) => name != null ? name : 'Guest';

// Очень длинная версия использует оператор if-else.
String playerName(String name) {
  if (name != null) {
    return name;
  } else {
    return 'Guest';
  }
}
```

### Каскадная запись

Каскады `..` позволяют выполнять последовательность операций над одним и тем же объектом. Помимо вызовов функций, также можно получить доступ к полям того же объекта. Это часто избавляет от необходимости создавать временную переменную и позволяет писать более гибкий код.

Пример:

```dart
querySelector('#confirm') // Получить объект.
  ..text = 'Confirm' // Использовать его члены.
  ..classes.add('important')
  ..onClick.listen((e) => window.alert('Confirmed!'));
```

Первый вызов метода `querySelector()` возвращает объект селектора. Код, следующий за каскадной нотацией, работает с этим селекторным объектом, игнорируя любые последующие значения, которые могут быть возвращены.

Предыдущий пример эквивалентен:

```dart
var button = querySelector('#confirm');
button.text = 'Confirm';
button.classes.add('important');
button.onClick.listen((e) => window.alert('Confirmed!'));
```

Также можно вкладывать каскады. Например:

```dart
final addressBook = (AddressBookBuilder()
      ..name = 'jenny'
      ..email = 'jenny@example.com'
      ..phone = (PhoneNumberBuilder()
            ..number = '415-555-0100'
            ..label = 'home')
          .build())
    .build();
```

Нужно быть осторожным, создавая каскад на основе функции, возвращающей реальный объект. Например, следующий код не работает:

```dart
var sb = StringBuffer();
sb.write('foo')
  ..write('bar'); // Ошибка: метод "write" не определен для "void".
```

Вызов `sb.write()` возвращает `void`, и не возможно построить каскад на `void`.

> **Примечание**: Обозначение каскадов «двойной точкой» не является оператором. Это просто часть синтаксиса Dart.

### Другие операторы

| Оператор | Название                | Значение                                                     |
| -------- | ----------------------- | ------------------------------------------------------------ |
| `()`     | Вызов функции           | Представляет вызов функции                                   |
| `[]`     | Доступ к списку         | Ссылается на значение по указанному индексу в списке         |
| `.`      | Доступ к члену          | Ссылается но свойство выражения; пример: `foo.bar` выбирает свойство `bar` из выражения `foo` |
| `?.`     | Условный доступ к члену | Как `.`, но крайний левый операнд может быть `null`; пример: `foo?.bar` ссылается на свойство  `bar` из выражения `foo` если только `foo` равна `null` (в этом случае значение `foo?.bar` равно `null`) |

## Операторы управления потоком

В Dart можно управлять потоком кода, используя любое из следующих действий:

- `if` и `else`
- цикл `for`
- циклы `while` и `do-while`
- `break` и `continue`
- `switch` и `case`
- `assert`

Также можно повлиять на поток управления с помощью `try-catch` и `throw`.

### If и else

Dart поддерживает операторы `if` с необязательными операторами `else`, как показано в следующем примере. 

```dart
if (isRaining()) {
  you.bringRainCoat();
} else if (isSnowing()) {
  you.wearJacket();
} else {
  car.putTopDown();
}
```

В отличие от JavaScript, условия должны использовать логические значения, ничего больше.

### Цикл for

Можно использовать стандартный цикл `for`. Например:

```dart
var message = StringBuffer('Dart is fun');
for (var i = 0; i < 5; i++) {
  message.write('!');
}
```

Замыкания внутри циклов `for` в Dart фиксируют значение индекса, избегая распространенной ошибки, обнаруживаемой в JavaScript. Например:

```dart
var callbacks = [];
for (var i = 0; i < 2; i++) {
  callbacks.add(() => print(i));
}
callbacks.forEach((c) => c());
```

Результатом будет `0`, а затем `1`, как и ожидалось. Напротив в JavaScript будет напечатано `2`, и затем `2`.

Если объект, который вы повторяете, является итерируемым, то можно использовать метод `forEach()`. Использование `forEach()` - хороший вариант, если не нужно знать текущий счетчик итераций:

```dart
candidates.forEach((candidate) => candidate.interview());
```

Итерируемые классы, такие как `List` и `Set`, также поддерживают итерацию `for-in`:

```dart
var collection = [1, 2, 3];
for (var x in collection) {
  print(x); // 1 2 3
}
```

### While и do-while

Цикл `while` оценивает условие перед циклом:

```dart
while (!isDone()) {
  doSomething();
}
```

Цикл `do-while` оценивает условие после цикла:

```dart
do {
  printLine();
} while (!atEndOfPage());
```

### Break и continue

Чтобы остановить цикл нужно использовать `break`:

```dart
while (true) {
  if (shutDownRequested()) break;
  processIncomingRequests();
}
```

Чтобы перейти к следующей итерации цикла используется `continue`:

```dart
for (int i = 0; i < candidates.length; i++) {
  var candidate = candidates[i];
  if (candidate.yearsExperience < 5) {
    continue;
  }
  candidate.interview();
}
```

Можно написать этот пример по-другому, если использовать [Iterable](https://api.dart.dev/stable/dart-core/Iterable-class.html), например список или набор:

```dart
candidates
    .where((c) => c.yearsExperience >= 5)
    .forEach((c) => c.interview());
```

### Switch и case

Операторы `switch` в Dart сравнивают целочисленные, строковые или константы времени компиляции с помощью `==`. Все сравниваемые объекты должны быть экземплярами одного и того же класса (а не любого из его подтипов), и этот класс не должен переопределять `==`. Перечислимые типы хорошо работают в операторах `switch`.

> **Примечание**: операторы `switch` в Dart предназначены для ограниченных случаев, например, в интерпретаторах или сканерах.

Каждое непустое предложение `case`, как правило, заканчивается оператором `break`. Другими допустимыми способами завершения непустого предложения `case` являются операторы `continue`, `throw` или `return`.

Пункт `default` используется для выполнения кода, когда не подходит ни один из  `case`:

```dart
var command = 'OPEN';
switch (command) {
  case 'CLOSED':
    executeClosed();
    break;
  case 'PENDING':
    executePending();
    break;
  case 'APPROVED':
    executeApproved();
    break;
  case 'DENIED':
    executeDenied();
    break;
  case 'OPEN':
    executeOpen();
    break;
  default:
    executeUnknown();
}
```

В следующем примере оператор `break` отсутствует в пункте `case`, что приводит к ошибке:

```dart
var command = 'OPEN';
switch (command) {
  case 'OPEN':
    executeOpen();
    // Ошибка: Недостает break

  case 'CLOSED':
    executeClosed();
    break;
}
```

Тем не менее, Dart поддерживает пустые `case`, что позволяет избежать отказа:

```dart
var command = 'CLOSED';
switch (command) {
  case 'CLOSED': // Пустой case проваливается дальше.
  case 'NOW_CLOSED':
    // Работает для обоих CLOSED и NOW_CLOSED.
    executeNowClosed();
    break;
}
```

Если действительно нужно провалиться дальше, то можно использовать оператор `continue` и метку:

```dart
var command = 'CLOSED';
switch (command) {
  case 'CLOSED':
    executeClosed();
    continue nowClosed;
  // Продолжает выполнение на метке nowClosed

  nowClosed:
  case 'NOW_CLOSED':
    // Работает для обоих CLOSED и NOW_CLOSED.
    executeNowClosed();
    break;
}
```

Пункт `case` может иметь локальные переменные, которые видны только внутри области действия этого предложения.

### Assert

Во время разработки можно использовать оператор утверждения - `assert(condition, optionalMessage);` - чтобы прервать нормальное выполнение, если логическое условие ложно. В этом туре можно найти примеры утверждений. Вот еще несколько:

```dart
// Убедитесь, что переменная имеет ненулевое значение.
assert(text != null);

// Убедитесь, что значение меньше 100.
assert(number < 100);

// Убедитесь, что это URL-адрес https.
assert(urlString.startsWith('https'));
```

Чтобы прикрепить сообщение к утверждению, добавьте строку в качестве второго аргумента в `assert` (не обязательно с конечной запятой):

```dart
assert(urlString.startsWith('https'),
    'URL ($urlString) should start with "https".');
```

Первым аргументом `assert` может быть любое выражение, которое разрешается в логическое значение. Если значение выражения истинно, утверждение завершается успешно и выполнение продолжается. Если значение ложно, то утверждение не выполняется и выдается исключение ([AssertionError](https://api.dart.dev/stable/dart-core/AssertionError-class.html)).

Когда именно утверждения работают? Это зависит от инструментов и фреймворка, которые используются:

- Flutter включает утверждения в [режиме отладки](https://flutter.dev/docs/testing/debugging#debug-mode-assertions).
- Инструменты только для разработки, такие как [dartdevc](https://dart.dev/tools/dartdevc), обычно по умолчанию включают утверждения.
- Некоторые инструменты, такие как [dart](https://dart.dev/server/tools/dart-vm) и [dart2js](https://dart.dev/tools/dart2js), поддерживают утверждения с помощью флага командной строки: `--enable-asserts`.

В производственном коде утверждения игнорируются, а аргументы для `assert` не оцениваются.

## Исключения

Код в Dart может генерировать и перехватывать исключения. Исключения - это ошибки, указывающие на то, что произошло что-то непредвиденное. Если исключение не обнаружено, изолятор, вызвавший исключение, приостанавливается, и обычно изолятор и его программа завершаются.

В отличие от Java, все исключения Dart являются непроверенными. Методы не объявляют, какие исключения они могут вызвать, и вам не требуется перехватывать какие-либо исключения.

Dart предоставляет типы `Exception` и `Error`, а также множество предопределенных подтипов. Конечно, можно определять свои собственные исключения. Однако программы Dart могут выдавать любой ненулевой объект, а не только объекты `Exception` и `Error`, в качестве исключения.

### Throw

Вот пример создания исключения:

```dart
throw FormatException('Expected at least 1 section');
```

Также можно выбрасывать произвольные объекты:

```dart
throw 'Out of llamas!';
```

> **Примечание**: Код производственного качества обычно генерирует типы, реализующие [Error](https://api.dart.dev/stable/dart-core/Error-class.html) или [Exception](https://api.dart.dev/stable/dart-core/Exception-class.html).

Поскольку генерирование исключения является выражением, можно генерировать исключения в операторах `=>`, а также в любом другом месте, где разрешены выражения:

```dart
void distanceTo(Point other) => throw UnimplementedError();
```

### Catch

Перехват или захват исключения останавливает распространение исключения (если только не выбросить повторно исключение). Перехват исключения дает шанс справиться с ним:

```dart
try {
  breedMoreLlamas();
} on OutOfLlamasException {
  buyMoreLlamas();
}
```

Для обработки кода, который может вызывать более одного типа исключений, можно указать несколько  `catch`. Первый  `catch`, соответствующий типу выброшенного объекта, обрабатывает исключение. Если в `catch` не указан тип, то он может обрабатывать любой тип брошенного объекта:

```dart
try {
  breedMoreLlamas();
} on OutOfLlamasException {
  // Определенное исключение
  buyMoreLlamas();
} on Exception catch (e) {
  // Все остальное, что является исключением
  print('Unknown exception: $e');
} catch (e) {
  // Нет указанного типа, обрабатывает все
  print('Something really unknown: $e');
}
```

Как показывает предыдущий код, можно использовать либо `on`, либо `catch`, либо оба. Они используйтся, когда нужно указать тип исключения. `catch` используется, когда обработчику исключений нужен объект исключения.

Можно указать один или два параметра для `catch()`. Первое - это возникшее исключение, а второе - трассировка стека (объект [StackTrace](https://api.dart.dev/stable/dart-core/StackTrace-class.html)).

```dart
try {
  // ···
} on Exception catch (e) {
  print('Exception details:\n $e');
} catch (e, s) {
  print('Exception details:\n $e');
  print('Stack trace:\n $s');
}
```

Чтобы частично обработать исключение, можно использовать ключевое слово `rethrow`.

```dart
void misbehave() {
  try {
    dynamic foo = true;
    print(foo++); // Ошибка выполнения
  } catch (e) {
    print('misbehave() partially handled ${e.runtimeType}.');
    rethrow; // Разрешить вызывающим видеть исключение.
  }
}

void main() {
  try {
    misbehave();
  } catch (e) {
    print('main() finished handling ${e.runtimeType}.');
  }
}
```

### Finaly

Чтобы гарантировать выполнение некоторого кода вне зависимости от того, возникло ли исключение, используйте предложение `finally`. Если ни одно предложение `catch` не соответствует исключению, исключение распространяется после выполнения предложения `finally`:

```dart
try {
  breedMoreLlamas();
} finally {
  // Всегда выполняйте очистку, даже если возникнет исключение.
  cleanLlamaStalls();
}
```

`finally` выполняется после любых подходящих предложений `catch`:

```dart
try {
  breedMoreLlamas();
} catch (e) {
  print('Error: $e'); // Сначала обработай исключение
} finally {
  cleanLlamaStalls(); // Затем очисти
}
```

## Классы

Dart - объектно-ориентированный язык с классами и наследованием на основе миксинов. Каждый объект является экземпляром класса, а все классы происходят от [Object](https://api.dart.dev/stable/dart-core/Object-class.html). *Наследование на основе миксинов* означает, что, хотя каждый класс (кроме Object) имеет ровно один класс родитель, тело класса можно повторно использовать в нескольких иерархиях классов. Методы расширения - это способ добавления функциональности к классу без изменения класса или создания подкласса.

### Использование членов класса

Объекты имеют *члены*, состоящие из функций и данных (*методов* и *переменных экземпляра* соответственно). Когда вызывается метод, то вызов идет для его объекта: метод имеет доступ к функциям и данным этого объекта.

Для ссылки на переменную или метод экземпляра используется точка (`.`) :

```dart
var p = Point(2, 2);

// Присвоение значения переменной y экземпляра p.
p.y = 3;

// Получение значения y.
assert(p.y == 3);

// Вызоа distanceTo() из p.
double distance = p.distanceTo(Point(4, 4));
```

Можно использовать `?.` вместо того `.`, чтобы избежать исключения, когда крайний левый операнд равен нулю:

```dart
// Если p не null, установить y значение 4.
p?.y = 4;
```

### Использование конструкторов

Создать объект можно при помощи *конструктора*. Имена конструкторов могут быть либо `ClassName` или  `ClassName.identifier`.  Например, следующий код создает объект `Point` используя конструкторы `Point()` и `Point.fromJson()`:

```dart
var p1 = Point(2, 2);
var p2 = Point.fromJson({'x': 1, 'y': 2});
```

Следующий код имеет тот же эффект, но использует необязательное ключевое слово new перед именем конструктора:

```dart
var p1 = new Point(2, 2);
var p2 = new Point.fromJson({'x': 1, 'y': 2});
```

> **Примечание к версии**: новое ключевое слово стало необязательным в Dart 2.

Некоторые классы предоставляют постоянные конструкторы. Чтобы создать константу времени компиляции с помощью конструктора констант, нужно поместить ключевое слово `const` перед именем конструктора:

```dart
var p = const ImmutablePoint(2, 2);
```

Создание двух идентичных констант времени компиляции приводит к единому каноническому экземпляру:

```dart
var a = const ImmutablePoint(1, 1);
var b = const ImmutablePoint(1, 1);

assert(identical(a, b)); // Это один и тот же экземпляр!
```

В постоянном контексте можно опустить `const` перед конструктором или литералом. Например, посмотрите на этот код, который создает `const map`:

```dart
// Здесь много ключевых слов const.
const pointAndLine = const {
  'point': const [const ImmutablePoint(0, 0)],
  'line': const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],
};
```

Если константный конструктор находится вне константного контекста и вызывается без константы, он создает не константный объект:

```dart
var a = const ImmutablePoint(1, 1); // Создает константу
var b = ImmutablePoint(1, 1); // НЕ создает константу

assert(!identical(a, b)); // Не тот же самый экземпляр!
```

> **Примечание к версии**: ключевое слово const стало необязательным в постоянном контексте в Dart 2.

### Переменные экземпляра

Вот как объявляются переменные экземпляра:

```dart
class Point {
  double x; // Объявляеься переменная экземпляра x, инициализируется null-ом.
  double y; // Объявляется y, инициализируется null-ом.
  double z = 0; // Объявляется z, инициализируется 0.
}
```

Все неинициализированные переменные экземпляра имеют значение `null`.

Все переменные экземпляра генерируют неявный метод `getter`.  Не константные переменные экземпляра также иницилизируют метод `setter`. 

```dart
class Point {
  double x;
  double y;
}

void main() {
  var point = Point();
  point.x = 4; // Использование метода setter для x.
  assert(point.x == 4); // Использование метода getter для x.
  assert(point.y == null); // Значения по умолчанию равны null.
}
```

Если инициализировать переменную экземпляра там, где она объявлена (а не в конструкторе или методе), то значение устанавливается при создании экземпляра, то есть до выполнения конструктора и его списка инициализаторов.

### Конструкторы

Конструктор объявляется созданием функции с тем же именем, что и его класс (плюс, необязательно, дополнительный идентификатор). Наиболее распространенная форма конструктора, генеративный конструктор, создает новый экземпляр класса:

```dart
class Point {
  double x, y;

  Point(double x, double y) {
    // Есть лучший способ сделать это.
    this.x = x;
    this.y = y;
  }
}
```

Ключевое слово `this` относится к текущему экземпляру.

> **Примечание**: Использовать `this` нужно только в случае конфликта имен. В противном случае в Dart пропускает `this`.

Шаблон присвоения аргумента конструктора переменной экземпляра настолько распространен, что в Dart есть синтаксический сахар, упрощающий его:

```dart
class Point {
  double x, y;

  // Синтаксический сахар для установки x и y
  // перед запуском тела конструктора.
  Point(this.x, this.y);
}
```

#### Конструкторы по умолчанию

Если не объявляется конструктор, то предоставляется конструктор по умолчанию. Конструктор по умолчанию не имеет аргументов и вызывает конструктор без аргументов в суперклассе.

#### Конструкторы не наследуются

Подклассы не наследуют конструкторы от своего суперкласса. Подкласс, который не объявляет никаких конструкторов, имеет только конструктор по умолчанию (без аргументов, без имени).

#### Именованные конструкторы

Именованный конструктор используется для реализации нескольких конструкторов класса или для обеспечения дополнительной ясности:

```dart
class Point {
  double x, y;

  Point(this.x, this.y);

  // Именованный конструктор
  Point.origin() {
    x = 0;
    y = 0;
  }
}
```

Конструкторы не наследуются, это означает, что именованный конструктор суперкласса не наследуется подклассом. Чтобы подкласс был создан с именованным конструктором, определенным в суперклассе, нужно реализовать этот конструктор в подклассе.

#### Вызов конструктора не по умолчанию суперкласса

По умолчанию конструктор подкласса вызывает безымянный конструктор суперкласса без аргументов. Конструктор суперкласса вызывается в начале тела конструктора. Если также используется список инициализаторов, он выполняется до вызова суперкласса. Таким образом, порядок исполнения следующий:

1. список инициализаторов 
2. конструктор суперкласса без аргументов 
3. конструктор основного класса без аргументов

Если у суперкласса нет безымянного конструктора без аргументов, необходимо вручную вызвать один из конструкторов суперкласса. Указывается конструктор суперкласса после двоеточия (`:`), непосредственно перед телом конструктора (если есть).

В следующем примере конструктор класса Employee вызывает именованный конструктор для своего суперкласса Person.

```dart
class Person {
  String firstName;

  Person.fromJson(Map data) {
    print('in Person');
  }
}

class Employee extends Person {
  // Person не имеет конструктора по умолчанию
  // необходимо вызывать super.fromJson(data).
  Employee.fromJson(Map data) : super.fromJson(data) {
    print('in Employee');
  }
}

main() {
  var emp = new Employee.fromJson({});

  // Выведет:
  // in Person
  // in Employee
  if (emp is Person) {
    // проверка типа
    emp.firstName = 'Bob';
  }
  (emp as Person).firstName = 'Bob';
}
```

Поскольку аргументы конструктора суперкласса оцениваются перед вызовом конструктора, аргумент может быть выражением, например вызовом функции:

```dart
class Employee extends Person {
  Employee() : super.fromJson(defaultData);
  // ···
}
```

> **Предупреждение**: аргументы конструктора суперкласса не имеют доступа к `this`. Например, аргументы могут вызывать статические методы, но не методы экземпляра.

#### Список инициализаторов

Помимо вызова конструктора суперкласса, также можно инициализировать переменные экземпляра перед запуском тела конструктора. Разделяйте инициализаторы запятыми.

```dart
// Список инициализаторов устанавливает переменные экземпляра перед
// тело конструктора запускается.
Point.fromJson(Map<String, double> json)
    : x = json['x'],
      y = json['y'] {
  print('In Point.fromJson(): ($x, $y)');
}
```

> **Предупреждение**: правая часть инициализатора не имеет доступа к `this`.

Во время разработки можно проверять вводимые данные, используя `assert` в списке инициализаторов.

```dart
Point.withAssert(this.x, this.y) : assert(x >= 0) {
  print('In Point.withAssert(): ($x, $y)');
}
```

Списки инициализаторов удобны при настройке `final` полей. В следующем примере инициализируются три последних поля в списке инициализаторов.

```dart
import 'dart:math';

class Point {
  final num x;
  final num y;
  final num distanceFromOrigin;

  Point(x, y)
      : x = x,
        y = y,
        distanceFromOrigin = sqrt(x * x + y * y);
}

main() {
  var p = new Point(2, 3);
  print(p.distanceFromOrigin);
}
```

#### Перенаправление конструкторов

Иногда единственная цель конструктора - перенаправить на другой конструктор того же класса. Тело конструктора перенаправления пусто, а его вызов появляется после двоеточия (`:`).

```dart
class Point {
  double x, y;

  // Главный конструктор этого класса.
  Point(this.x, this.y);

  // Перенаправление на главный конструктор.
  Point.alongXAxis(double x) : this(x, 0);
}
```

#### Постоянные конструкторы

Если класс создает объекты, которые никогда не меняются, то можно сделать эти объекты константами времени компиляции. Для этого определяется `const` конструктор и все переменные экземпляра должны быть `final`.

```dart
class ImmutablePoint {
  static final ImmutablePoint origin =
      const ImmutablePoint(0, 0);

  final double x, y;

  const ImmutablePoint(this.x, this.y);
}
```

Постоянные конструкторы не всегда создают константы.

#### Фабричные конструкторы

Используйте ключевое слово `factory` при реализации конструктора, который не всегда создает новый экземпляр своего класса. Например, фабричный конструктор может возвращать экземпляр из кеша или может возвращать экземпляр подтипа. Другой вариант использования фабричных конструкторов - инициализация конечной переменной с использованием логики, которая не может быть обработана в списке инициализаторов. В следующем примере фабричный конструктор `Logger` возвращает объекты из кеша, а фабричный конструктор `Logger.fromJson` инициализирует конечную переменную из объекта JSON.

```dart
class Logger {
  final String name;
  bool mute = false;

  // _cache приватный, спасибо
  // _ в начале его имени.
  static final Map<String, Logger> _cache =
      <String, Logger>{};

  factory Logger(String name) {
    return _cache.putIfAbsent(
        name, () => Logger._internal(name));
  }

  factory Logger.fromJson(Map<String, Object> json) {
    return Logger(json['name'].toString());
  }

  Logger._internal(this.name);

  void log(String msg) {
    if (!mute) print(msg);
  }
}
```

> **Примечание**: Фабричные конструкторы не имеют доступа к `this`.

Фабричный конструктор вызывается так же, как любой другой конструктор:

```dart
var logger = Logger('UI');
logger.log('Button clicked');

var logMap = {'name': 'UI'};
var loggerJson = Logger.fromJson(logMap);
```

### Методы

Методы - это функции, которые предустанавливают поведение объекта.

#### Методы экземпляра

Методы экземпляра объектов могут обращаться к переменным экземпляра и `this`.  Метод `distanceTo()` в следующем примере является примером метода экземпляра:

```dart
import 'dart:math';

class Point {
  double x, y;

  Point(this.x, this.y);

  double distanceTo(Point other) {
    var dx = x - other.x;
    var dy = y - other.y;
    return sqrt(dx * dx + dy * dy);
  }
}
```

#### Операторы

Операторы - это методы экземпляра со специальными именами. Dart позволяет определять операторы со следующими именами:

| `<`  | `+`  | `|`  | `[]`  |
| ---- | ---- | ---- | ----- |
| `>`  | `/`  | `^`  | `[]=` |
| `<=` | `~/` | `&`  | `~`   |
| `>=` | `*`  | `<<` | `==`  |
| `–`  | `%`  | `>>` |       |

> **Примечание**. Некоторых операторов, например `! =`, нет в списке имен. Это потому, что они всего лишь синтаксический сахар. Например, выражение `e1 != e2` является синтаксическим сахаром для `!(e1 == e2)`.

Объявление оператора идентифицируется с помощью встроенного идентификатора `operator`. В следующем примере определяется сложение векторов (`+`) и вычитание (`-`):

```dart
class Vector {
  final int x, y;

  Vector(this.x, this.y);

  Vector operator +(Vector v) => Vector(x + v.x, y + v.y);
  Vector operator -(Vector v) => Vector(x - v.x, y - v.y);

  // Оператор == и hashCode не показаны.
  // ···
}

void main() {
  final v = Vector(2, 3);
  final w = Vector(2, 2);

  assert(v + w == Vector(4, 5));
  assert(v - w == Vector(0, 1));
}
```

#### Геттеры и сеттеры

Геттеры и сеттеры - это специальные методы, которые обеспечивают доступ для чтения и записи свойств объекта. Напомним, что каждая переменная экземпляра имеет неявный геттер, а также, при необходимости, сеттер. Можено создавать дополнительные свойства, реализуя методы получения (геттеры) и установки (сеттеры) значений, используя ключевые слова `get` и `set`:

```dart
class Rectangle {
  double left, top, width, height;

  Rectangle(this.left, this.top, this.width, this.height);

  // Определение двух вычисляемых свойств: right и bottom.
  double get right => left + width;
  set right(double value) => left = value - width;
  double get bottom => top + height;
  set bottom(double value) => top = value - height;
}

void main() {
  var rect = Rectangle(3, 4, 20, 15);
  assert(rect.left == 3);
  rect.right = 12;
  assert(rect.left == -8);
}
```

Используя геттеры и сеттеры, можно начать с переменных экземпляра, а затем обернуть их методами, и все это без изменения клиентского кода. 

> **Примечание**: Такие операторы, как инкремент (`++`), работают ожидаемым образом, независимо от того, определен ли геттер явно. Чтобы избежать неожиданных побочных эффектов, оператор вызывает метод получения ровно один раз, сохраняя его значение во временной переменной.

#### Абстрактные методы

Методы экземпляра, геттеры и сеттеры могут быть абстрактными, определяя интерфейс, но оставляя его реализацию другим классам. Абстрактные методы могут существовать только в абстрактных классах.

Чтобы сделать метод абстрактным, используется точка с запятой (`;`) вместо тела метода:

```dart
abstract class Doer {
  // Определение переменных экземпляра и методов ...

  void doSomething(); // Определение абстрактного метода.
}

class EffectiveDoer extends Doer {
  void doSomething() {
    // Описывается реализацию, чтобы метод здесь не был абстрактным ...
  }
}
```

### Абстрактные классы

