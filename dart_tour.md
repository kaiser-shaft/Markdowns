# Dart - язык программирования

## Важные концепции

- Все что можно поместить в переменную является объектом, каждый объект является экземпляром класса. Числа, функции и даже `null` явлеяется объектом. Все объекты наследуются от класса `Object`.
- Хотя Dart строго типизирован, аннотации типов необязательны, поскольку Dart может определять типы. Если вы хотите явно сказать, что никакого типа не ожидается, используйте специальный тип `dynamic`.
- Dart поддерживает обобщения, такие как `List<int>` или `List<dynamic>`.
- Dart поддерживает функции верхнего уровня (такие как `main()`), также функции связанные с классами или объектами (статические или методы объектов). Можно также создавать функции внутри функций (вложенные или локальные)
- Dart поддерживает переменные верхнего уровня (глобальные), также как и связанные с классами или объектами. Переменные состояния также иногда называют полями или свойствами.
- Идендификатор, начинающийся со знака подчеркивания (_) является приватным.
- Идендификаторы могут начинаться со знака подчеркивания с последующим написанием любых букв и цифр.
- В Dart есть как выражения, так и операторы.(`condition ? expr1 : expr2` - `if() { } else { }`)
- Инструменты Dart могут сообщить о 2х типах проблем: предупреждения (warnings) и ошибки (errors).

## Переменные

Пример объявления и инициализации переменной:

```dart
var name = 'Bob';
```

Переменная - ссылка на объект. Переменная `name` содержит ссылку на объект типа `String` со значением "Bob".

Если объект не должен содержать значения определенного класса, то его можно описать типом `Object` или `dynamic`.

```dart
dynamic name = 'Bob';
```

Можно также явно указать тип переменной при её объявлении:

```dart
String name = 'Bob';
```

### Значение по-умолчанию

Не инициализированные переменные имеют значение `null`. Даже переменные числового типа инициализируются null-ом. Потому что в Dart всё является объектами.

```dart
int lineCount;
assert(lineCount == null);
```

> **Примечание**: Окончательный код игнорирует `assert()`. Во время дебагинга `assert(выражение)` выбрасывает ошибку, если результат выражения ложный.

### Final и const

Если значение переменной не должно меняться, то нужно использовать `final` или `const` вместо `var` . `final` - значение объявляется только один раз; `const` - постоянная времени компиляции. final верхнего уровня или переменная класса инициализируется во время первого использования.

>  **Примечание**: Переменная экземляра может быть `final` но не `const`. Final  объект должен быть инициализирован до начала тела конструктора - в месте описания параметров конструктора или в [листе инициализации](https://dart.dev/guides/language/language-tour#initializer-list) коструктора.

```dart
final name = 'Bob'; // без анотации типа
final String nickname = 'Bobby';
```

Если `const` находится в классе, то она помечается как статическая (`static`). В месте где объявляется константа значение устанавливается из таких же констант как цифровые или строчные литералы, другие константы, или результаты арифметических операций между числовыми константами.

```dart
const bar = 100000;
const double atm = 1.01325 * bar;
```

Ключевое слово `const` используется не только для объявления констант. Его можно использовать для создания константных значений при объявлении конструкторов. Любый переменные могут иметь константное значение.

```dart
var foo = const [];
final var = const [];
const baz = []; // равнозначно const []
```

Значение, которое не имеет анотацию `final` или `const` можно изменять, даже если его значение было объявлено с использование `const`:

```dart
foo = [1, 2, 3]; // было const []
```

### Встроеные типы

Dart поддерживает следующие типы:

- числа
- строки
- логический тип
- списки
- наборы
- словари
- руны (для выражения символо юникода в строке)
- символы

Некоторые из встроенных типов имеют свои конструкторы.

#### Числа

[int](https://api.dart.dev/stable/dart-core/int-class.html)

Целочисленные значения не больше 64 бит в зависимости от платформы. В Dart VM значения могут быть от -2<sup>63</sup> до 2<sup>63</sup> - 1. При компиляции в JavaScript допустимые значения -2<sup>53</sup> до 2<sup>53</sup> - 1.

[double](https://api.dart.dev/stable/dart-core/double-class.html)

Дробные числа двойной точности 64 бит.

`int` и `double` являются подтипами [num](https://api.dart.dev/stable/dart-core/num-class.html)

```dart
var x = 1; // int
var hex = 0xDEADBEEF; // int
var y = 1.1; // double
var exponents = 1.4e5; // double
double z = 1; // integer 1 convert to double 1.0
```

Строки можно конвертировать в числа  и наоборот:

```dart
// String -> int
var one = int.parse('1');
// String -> double
var onePointOne = double.parse('1.1');
// int -> String
String oneAsString = 1.toString();
// double -> String
String piAsString = 3.14159.toStringAsFixed(2); // '3.14'
```

Для целых числах есть побитовые операторы сдвига ( `<<` , `>>` ), и ( `&`), или ( `|` ):

```dart
3 << 1 // 0011 << 1 -> 0110
3 >> 1 // 0011 >> 1 -> 0001
3 | 4  // 0011 | 0100 -> 0111
```

#### Строки

Строки в Dart являются последовательностью из символов UTF-16. Для их создания можно использовать двойные или одинарные ковычки.

```dart
var s1 = 'Single quotes work well for string literals.';
var s2 = "Double quotes work just as well.";
var s3 = 'It\'s easy to escape the string delimiter.';
var s4 = "It's even easier to use the other delimiter.";
```

Возможно вставлять выражение в строку используя `${выражение}`. Также можно вставлять идентификатор переменной, тогда {} можно опустить. Чтобы получить строку соответсвующую объекту можно вызвать метод `toString()`.

```dart
var s = 'интерполяция строк';

assert('В Dart есть $s, которая очень удобна.' ==
    'В Dart есть интерполяция строк, ' +
        'которая очень удобна.');
assert('${s.toUpperCase()} очень удобна!' ==
        'ИНТЕРПОЛЯЦИЯ СТРОК очень удобна!');
```

Сцепить строки можно при помощи оператора `+`:

```dart
var s1 = 'Оператор + ' + 'работает хорошо.';
var s2 = 'Конкатенация строк работает даже если'
    	  "строка разорвется.";
```

Для создание многострочной записи используются тройные одинарные или двойные ковычки:

```dart
var s1 = '''
Вы можете создать
многострочню запись вот так.
''';

var s2 = """Это также
многострочная запись.""";
```

Можно создать строку с игнорированием escape-последовательностей и спецсимволов:

```dart
var s = r'В raw-строке даже \n не получает особого отношения';
```

Строковой литерал является константой времени компиляции если он состоит также из выражений констант времени компиляции таких как null или числа, строки или логические переменные.

```dart
// Это работает в строковой константе
const aConstNum = 0;
const aConstBool = true;
const aConstString = 'строковая константа';

// Это работает в строковой константе
var aNum = 0;
var aBool = true;
var aString = 'строка';
const aConstList = [1, 2, 3];

const validConstString = '$aConstNum $aConstBool $aConstString';
// const invalidConstString = '$aNum $aBool $aString $aConstList';
```

#### Логический тип

Логический тип имеет только два объекта `true` и `false`, которые являются константами времени компиляции.

В Dart не возможно использовать не булево выражение в `if` или `assert`. Вместо этого нужно явно проверять значение переменной:

```dart
// Проверка пуста ли строка
var fullName = '';
assert(fullName.isEmpty);

// Проверка на ноль
var hitPoints = 0;
assert(hitPoints <= 0);

// Проверка на null
var unicorn;
assert(unicorn == null);

// Проверка на NaN.
var iMeantToDoThis = 0 / 0;
assert(iMeantToDoThis.isNaN);
```

#### Списки 

[List](https://api.dart.dev/stable/dart-core/List-class.html)

В Dart массивы - это объекты `List`.

```dart
var list = [1, 2, 3];
```

> **Примечание**: `list` имеет тип `List<int>`. Если попробовать добавить в этот список не целочисленно значение, то это приведет к ошибке.

Можно добавить запятую после последнего элемента списка. Эта запятая не будет влиять на всю коллекцию, но это поможет избежать ошибок копирования.

```dart
var list = [
  'Car',
  'Boat',
  'Plane',
];
```

Нумерация в списках начинается с нуля.

```dart
var list = [1, 2, 3];
assert(list.length == 3);
assert(list[1] == 2);

list[1] = 1;
assert(list[1] == 1);
```

Чтобы создать список, который является константой времени компиляции, нужно добавить `const` до списочного литерала:

```dart
var constantList = const [1, 2, 3];
// constantList[1] = 1; // This line will cause an error.
```

Dart 2.3 появиля spread-оператор (`...`) и spread-оператор с нулевым значением (`...?`), которые обеспечивают краткий способ вставки нескольких значений в коллекцию.

```dart
var list = [1, 2, 3];
var list2 = [0, ...list];
assert(list2.length == 4);
```

Если значение выражения справа от spread-оператора может быть null, то нужно использовать spread-оператор с нулевым значением (`...?`)

```dart
var list;
var list2 = [0, ...?list];
assert(list2.length == 1);
```

При создании списков можно использовать условные конструкции и циклы:

```dart
var nav = [
  'Home',
  'Furniture',
  'Plants',
  if (promoActive) 'Outlet'
];

var listOfInts = [1, 2, 3];
var listOfStrings = [
  '#0',
  for (var i in listOfInts) '#$i'
];
```

#### Наборы

[Set](https://api.dart.dev/stable/dart-core/Set-class.html)

Набор в Dart это неупорядоченная коллекция уникальных значений.

```dart
// halogens имеет тип Set<String>
var halogens = {'fluorine', 'chlorine', 'bromine', 'iodine', 'astatine'};
```

Для создания набора можно использовать пустую `{}`, которой предшевствует тип, или назначить `{}` переменной типа `Set`:

```dart
var names = <String>{};
Set<String> something = {}; 
// var names = {}; // компилятор не поймет какого типа набор
```

>  **Примечание**: Поскольку словари (`Map`) в Dart появились раньше наборов, то если забыть анотацию к `{}`, то для переменной создастся объект типа `Map<dynamic, dynamic>`

Для добавление элементов к существующему набору используются `add()` или `addAll()` методы:

```dart
var elements = <String>{};
elements.add('fluorine');
elements.addAll(halogens);
```

Для получения количества элементов в наборе используется `.length`:

```dart
assert(elements.length == 5);
```

Чтобы создать набор, который является константой времени компиляци, нужно добавлять `const` до установки литералов:

```dart
final constantSet = const {
  'fluorine',
  'chlorine',
  'bromine',
  'iodine',
  'astatine',
};
// constantSet.add('helium'); // Эта строка содержит ошибку.
```

Наборы также поддерживают spread-оператор (`...`), nullspread-operator (`...?`), условные конструкции (`if`) и циклы (`for`), также как и списки.

#### Словари

[Map](https://api.dart.dev/stable/dart-core/Map-class.html)

Словари состоят из ключей и значений. И ключи, и значения могут быть объектами любого типа. Ключ является уникальным, а значение может встречаться в словаре сколько угодно раз.

```dart
var gifts = {
  // Key:    Value
  'first': 'partridge',
  'second': 'turtledoves',
  'fifth': 'golden rings'
};

var nobleGases = {
  2: 'helium',
  10: 'neon',
  18: 'argon',
};
```

Словари можно создать и инициализировать по другому:

```dart
var gifts = Map();
gifts['first'] = 'partridge';
gifts['second'] = 'turtledoves';
gifts['fifth'] = 'golden rings';

var nobleGases = Map();
nobleGases[2] = 'helium';
nobleGases[10] = 'neon';
nobleGases[18] = 'argon';
```

> **Примечение**: словарь можно создать и так `new Map()`, но слово `new` в Dart не обязательно.

```dart
// инициализация словаря
var gifts = {'first': 'partridge'};
// добавление новой пары ключ-значение
gifts['fourth'] = 'calling birds'; 
// получение значения из словаря по ключу
assert(gifts['first'] == 'partridge');
// проверка имеется ли ключ в словаре
assert(gifts['fifth'] == null);
// количество пар в словаре
assert(gifts.length == 2);
```

Словарь можно создать как константу времени компиляции при помощи `const`:

```dart
final constantMap = const {
  2: 'helium',
  10: 'neon',
  18: 'argon',
};

// constantMap[2] = 'Helium'; // This line will cause an error.
```

Словари поддерживают spread-оператор (`...`), nullspread-operator (`...?`), условные конструкции (`if`) и циклы (`for`).

#### Руны и графемы

[Runes](https://api.dart.dev/stable/2.10.4/dart-core/Runes-class.html)

В Dart руны раскрывают кодовые точки Unicode строки.

Юникод определяет уникальное числовое значение для каждой буквы, цифры и символа, используемых во всех мировых системах письма. Поскольку строка Dart представляет собой последовательность кодовых единиц UTF-16, для выражения кодовых точек Unicode внутри строки требуется специальный синтаксис. Обычный способ обозначения кодовой точки Unicode - `\uXXXX`, где `XXXX` - 4-значное шестнадцатеричное значение. Например, символ сердца (`♥`) - `\u2665`. Чтобы указать более или менее 4 шестнадцатеричных цифр, заключите значение в фигурные скобки. Например, смеющийся смайлик (`😆`) - это `\u{1f606}`.

Если нужно прочитать или записать отдельные символы Unicode, нужно использовать метод получения символов, определенный в `String` пакет символов. Возвращенный объект `Characters` представляет собой строку как последовательность графем.

```dart
import 'package:characters/characters.dart';
...
var hi = 'Hi 🇩🇰';
print(hi);
print('The end of the string: ${hi.substring(hi.length - 1)}');
print('The last character: ${hi.characters.last}\n');
```

Результат:

```
$ dart bin/main.dart
Hi 🇩🇰
The end of the string: ???
The last character: 🇩🇰
```

#### Символы

[Symbol](https://api.dart.dev/stable/2.10.4/dart-core/Symbol-class.html)

Объект `Symbol` представляет собой оператор или идентификатор, объявленный в программе Dart. Возможно, вам никогда не понадобится использовать символы, но они бесценны для API, которые ссылаются на идентификаторы по имени, потому что минификация изменяет имена идентификаторов, но не символы идентификаторов.

Чтобы получить символ для идентификатора, используйте литерал символа, который представляет собой просто `#`, за которым следует идентификатор:

```dart
#radix
#bar
```

## Функции

Dart - настоящий объектно-ориентированный язык, поэтому даже функции являются объектами и имеют тип [Function](https://api.dart.dev/stable/dart-core/Function-class.html). Это означает, что функции могут быть присвоены переменным или переданы в качестве аргументов другим функциям. Можно вызвать экземпляр класса Dart, как если бы это была функция.

Вот пример реализации функции:

```dart
bool isNoble(int atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}
```

Хотя рекомендуется использовать аннотации типов для общедоступных API, функция по-прежнему работает, если вы опускаете типы

```dart
isNoble(atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}
```

Для функций, содержащих только одно выражение, можно использовать сокращенный синтаксис:

```dart
bool isNoble(int atomicNumber) => _nobleGases[atomicNumber] != null;
```

Синтаксис `=> expr` является сокращением для `{return expr; }`. Обозначение `=>` иногда называют синтаксисом *стрелки*.

> **Примечание**: Между стрелкой `=>` и точкой с запятой `;` может быть только выражение, но не оператор. Например, вы не можете поместить туда оператор `if`, но можете использовать условное выражение `expression ? true : false;`.

#### Параметры

Функция может иметь любое количество требуемых *позиционных* параметров. За ними могут следовать *именованные* параметры или *необязательные* позиционные параметры (но не оба сразу).

> **Примечание**: Некоторые API - особенно конструкторы виджетов [Flutter](https://flutter.dev/) - используют только именованные параметры, даже если параметры являются обязательными. 

Можно использовать [конечные запятые](https://dart.dev/guides/language/language-tour#trailing-comma) при передаче аргументов функции или при определении параметров функции.

##### Именнованные параметры

Именованные параметры являются необязательными, если они специально не отмечены как обязательные. 

При вызове функции вы можете указать именованные параметры, используя `paramName: value`. Например:

```dart
enableFlags(bold: true, hidden: false);
```

При определении функции используйте `{param1, param2, …}`, чтобы указать именованные параметры:

```dart
/// Sets the [bold] and [hidden] flags ...
void enableFlags({bool bold, bool hidden}) {...}
```

Хотя именованные параметры являются своего рода необязательными параметрами, вы можете аннотировать их с помощью `@required`, чтобы указать, что параметр является обязательным - что пользователи должны указать значение для параметра. Например:

```dart
const Scrollbar({Key key, @required Widget child})
```

Если кто-то пытается создать `Scrollbar` без указания `child`, анализатор сообщает о проблеме.

Чтобы использовать аннотацию `@required`  необходимо импортировать пакет: `meta/meta.dart`.

##### Необязательные позиционные параметры

Заключение набора параметров функции в `[]` отмечает их как необязательные позиционные параметры:

```dart
String say(String from, String msg, [String device]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  return result;
}
```

Вот пример вызова этой функции без необязательного параметра:

```dart
assert(say('Bob', 'Howdy') == 'Bob says Howdy');
```

А вот пример вызова этой функции с третьим параметром:

```dart
assert(say('Bob', 'Howdy', 'smoke signal') ==
    'Bob says Howdy with a smoke signal');
```

##### Значения параметров по умолчанию

Функция может использовать `=` для определения значений по умолчанию как для именованных, так и для позиционных параметров. Значения по умолчанию должны быть константами времени компиляции. Если значение по умолчанию не указано, значение по умолчанию - `null`.

Вот пример установки значений по умолчанию для названных параметров:

```dart
/// Sets the [bold] and [hidden] flags ...
void enableFlags({bool bold = false, bool hidden = false}) {...}

// bold will be true; hidden will be false.
enableFlags(bold: true);
```

> **Примечание**: старый код может использовать двоеточие `:` вместо `=` для установки значений по умолчанию для именованных параметров. Причина в том, что изначально поддерживалось только `:` для именованных параметров. Эта поддержка может быть устаревшей, поэтому мы рекомендуем использовать `=` для указания значений по умолчанию.

В следующем примере показано, как установить значения по умолчанию для позиционных параметров:

```dart
String say(String from, String msg,
    [String device = 'carrier pigeon']) {
  var result = '$from says $msg with a $device';
  return result;
}

assert(say('Bob', 'Howdy') ==
    'Bob says Howdy with a carrier pigeon');
```

Можно передавать списки или словари в качестве значений по умолчанию. В следующем примере определяется функция `doStuff()`, которая определяет список по умолчанию для параметра `list` и словарь по умолчанию для параметра `gifts`.

```dart
void doStuff(
    {List<int> list = const [1, 2, 3],
    Map<String, String> gifts = const {
      'first': 'paper',
      'second': 'cotton',
      'third': 'leather'
    }}) {
  print('list:  $list');
  print('gifts: $gifts');
}
```

#### Функция main()

аждое приложение должно иметь функцию верхнего уровня `main()`, которая служит точкой входа в приложение. 

Функция `main()` возвращает `void` и имеет необязательный параметр `List<String>` для аргументов.

Вот пример функции `main()` для веб-приложения:

```dart
void main() {
  querySelector('#sample_text_id')
    ..text = 'Click me!'
    ..onClick.listen(reverseText);
}
```

> **Примечание**: Синтаксис `..` в предыдущем коде называется каскадом. С помощью каскадов вы можете выполнять несколько операций с элементами одного объекта.

Вот пример функции `main()` для приложения командной строки, которое принимает аргументы:

```dart
// Run the app like this: dart args.dart 1 test
void main(List<String> arguments) {
  print(arguments);

  assert(arguments.length == 2);
  assert(int.parse(arguments[0]) == 1);
  assert(arguments[1] == 'test');
}
```

Можно использовать библиотеку [args](https://pub.dev/packages/args) для определения и анализа аргументов командной строки.

#### Функции как объекты класса

Можно передать функцию в качестве параметра другой функции. Например:

```dart
void printElement(int element) {
  print(element);
}

var list = [1, 2, 3];

// Pass printElement as a parameter.
list.forEach(printElement);
```

Также можно присвоить переменной функцию, например:

```dart
var loudify = (msg) => '!!! ${msg.toUpperCase()} !!!';
assert(loudify('hello') == '!!! HELLO !!!');
```

В этом примере используется анонимная функция.

#### Анонимные функции

Большинство функций имеют имена, например `main()` или `printElement()`. Также можно создать безымянную функцию, называемую *анонимной функцией*, или иногда *лямбда-выражением* или *замыканием*. Можно назначить анонимную функцию переменной, чтобы, например, добавить или удалить ее из коллекции.

Анонимная функция похожа на именованную функцию - ноль или более параметров, разделенных запятыми, и необязательные аннотации типов в круглых скобках.

Следующий блок кода содержит тело функции:

```
([[Type] param1[, …]]) {
  codeBlock;
};
```

В следующем примере определяется анонимная функция с нетипизированным параметром `item`. Функция, вызываемая для каждого элемента в списке, печатает строку, которая включает значение по указанному индексу.

```dart
var list = ['apples', 'bananas', 'oranges'];
list.forEach((item) {
  print('${list.indexOf(item)}: $item');
});
```

Если функция содержит только один оператор, можно сократить его, используя обозначения стрелок.

```dart
list.forEach(
    (item) => print('${list.indexOf(item)}: $item')
);
```

#### Лексическая область видимости

Dart - это язык с лексической областью видимости. Это означает, что область видимости переменных определяется статически, просто компоновкой кода. Можно «проследить за фигурными скобками», чтобы увидеть, входит ли переменная в область видимости.

Вот пример вложенных функций с переменными на каждом уровне области видимости:

```dart
bool topLevel = true;

void main() {
  var insideMain = true;

  void myFunction() {
    var insideFunction = true;

    void nestedFunction() {
      var insideNestedFunction = true;

      assert(topLevel);
      assert(insideMain);
      assert(insideFunction);
      assert(insideNestedFunction);
    }
  }
}
```

#### Лексические замыкания

*Замыкание* - это объект функции, который имеет доступ к переменным в своей лексической области видимости, даже если функция используется за пределами своей исходной области видимости.

Функции могут закрывать переменные, определенные в окружающих областях. В следующем примере `makeAdder()` захватывает переменную `addBy`. Куда бы ни отправилась возвращаемая функция, она запоминает `addBy`.

```dart
/// Returns a function that adds [addBy] to the
/// function's argument.
Function makeAdder(int addBy) {
  return (int i) => addBy + i;
}

void main() {
  // Create a function that adds 2.
  var add2 = makeAdder(2);

  // Create a function that adds 4.
  var add4 = makeAdder(4);

  assert(add2(3) == 5);
  assert(add4(3) == 7);
}
```

#### Проверка функций на равенство

Вот пример тестирования функций верхнего уровня, статических методов и методов экземпляра на равенство:

```dart
void foo() {} // A top-level function

class A {
  static void bar() {} // A static method
  void baz() {} // An instance method
}

void main() {
  var x;

  // Comparing top-level functions.
  x = foo;
  assert(foo == x);

  // Comparing static methods.
  x = A.bar;
  assert(A.bar == x);

  // Comparing instance methods.
  var v = A(); // Instance #1 of A
  var w = A(); // Instance #2 of A
  var y = w;
  x = w.baz;

  // These closures refer to the same instance (#2),
  // so they're equal.
  assert(y.baz == x);

  // These closures refer to different instances,
  // so they're unequal.
  assert(v.baz != w.baz);
}
```

#### Возвращаемые значения

Все функции возвращают значение. Если возвращаемое значение не указано, то оператор `return null;` неявно добавляется к телу функции.

```dart
foo() {}

assert(foo() == null);
```

### Операторы

