# Dart - язык программирования

## Важные концепции

- Все что можно поместить в переменную является объектом, каждый объект является экземпляром класса. Числа, функции и даже `null` явлеяется объектом. Все объекты наследуются от класса `Object`.
- Хотя Dart строго типизирован, аннотации типов необязательны, поскольку Dart может определять типы. Если вы хотите явно сказать, что никакого типа не ожидается, используйте специальный тип `dynamic`.
- Dart поддерживает обобщения, такие как `List<int>` или `List<dynamic>`.
- Dart поддерживает функции верхнего уровня (такие как `main()`), также функции связанные с классами или объектами (статические или методы объектов). Можно также создавать функции внутри функций (вложенные или локальные)
- Dart поддерживает переменные верхнего уровня (глобальные), также как и связанные с классами или объектами. Переменные состояния также иногда называют полями или свойствами.
- Идендификатор, начинающийся со знака подчеркивания (_) является приватным.
- Идендификаторы могут начинаться со знака подчеркивания с последующим написанием любых букв и цифр.
- В Dart есть как выражения, так и операторы.(`condition ? expr1 : expr2` - `if() { } else { }`)
- Инструменты Dart могут сообщить о 2х типах проблем: предупреждения (warnings) и ошибки (errors).

## Переменные

Пример объявления и инициализации переменной:

```dart
var name = 'Bob';
```

Переменная - ссылка на объект. Переменная `name` содержит ссылку на объект типа `String` со значением "Bob".

Если объект не должен содержать значения определенного класса, то его можно описать типом `Object` или `dynamic`.

```dart
dynamic name = 'Bob';
```

Можно также явно указать тип переменной при её объявлении:

```dart
String name = 'Bob';
```

### Значение по-умолчанию

Не инициализированные переменные имеют значение `null`. Даже переменные числового типа инициализируются null-ом. Потому что в Dart всё является объектами.

```dart
int lineCount;
assert(lineCount == null);
```

> **Примечание**: Окончательный код игнорирует `assert()`. Во время дебагинга `assert(выражение)` выбрасывает ошибку, если результат выражения ложный.

### Final и const

Если значение переменной не должно меняться, то нужно использовать `final` или `const` вместо `var` . `final` - значение объявляется только один раз; `const` - постоянная времени компиляции. final верхнего уровня или переменная класса инициализируется во время первого использования.

>  **Примечание**: Переменная экземляра может быть `final` но не `const`. Final  объект должен быть инициализирован до начала тела конструктора - в месте описания параметров конструктора или в [листе инициализации](https://dart.dev/guides/language/language-tour#initializer-list) коструктора.

```dart
final name = 'Bob'; // без анотации типа
final String nickname = 'Bobby';
```

Если `const` находится в классе, то она помечается как статическая (`static`). В месте где объявляется константа значение устанавливается из таких же констант как цифровые или строчные литералы, другие константы, или результаты арифметических операций между числовыми константами.

```dart
const bar = 100000;
const double atm = 1.01325 * bar;
```

Ключевое слово `const` используется не только для объявления констант. Его можно использовать для создания константных значений при объявлении конструкторов. Любый переменные могут иметь константное значение.

```dart
var foo = const [];
final var = const [];
const baz = []; // равнозначно const []
```

Значение, которое не имеет анотацию `final` или `const` можно изменять, даже если его значение было объявлено с использование `const`:

```dart
foo = [1, 2, 3]; // было const []
```

### Встроеные типы

Dart поддерживает следующие типы:

- числа
- строки
- логический тип
- списки
- наборы
- словари
- руны (для выражения символо юникода в строке)
- символы

Некоторые из встроенных типов имеют свои конструкторы.

#### Числа

[int](https://api.dart.dev/stable/dart-core/int-class.html)

Целочисленные значения не больше 64 бит в зависимости от платформы. В Dart VM значения могут быть от -2<sup>63</sup> до 2<sup>63</sup> - 1. При компиляции в JavaScript допустимые значения -2<sup>53</sup> до 2<sup>53</sup> - 1.

[double](https://api.dart.dev/stable/dart-core/double-class.html)

Дробные числа двойной точности 64 бит.

`int` и `double` являются подтипами [num](https://api.dart.dev/stable/dart-core/num-class.html)

```dart
var x = 1; // int
var hex = 0xDEADBEEF; // int
var y = 1.1; // double
var exponents = 1.4e5; // double
double z = 1; // integer 1 convert to double 1.0
```

Строки можно конвертировать в числа  и наоборот:

```dart
// String -> int
var one = int.parse('1');
// String -> double
var onePointOne = double.parse('1.1');
// int -> String
String oneAsString = 1.toString();
// double -> String
String piAsString = 3.14159.toStringAsFixed(2); // '3.14'
```

Для целых числах есть побитовые операторы сдвига ( `<<` , `>>` ), и ( `&`), или ( `|` ):

```dart
3 << 1 // 0011 << 1 -> 0110
3 >> 1 // 0011 >> 1 -> 0001
3 | 4  // 0011 | 0100 -> 0111
```

#### Строки

Строки в Dart являются последовательностью из символов UTF-16. Для их создания можно использовать двойные или одинарные ковычки.

```dart
var s1 = 'Single quotes work well for string literals.';
var s2 = "Double quotes work just as well.";
var s3 = 'It\'s easy to escape the string delimiter.';
var s4 = "It's even easier to use the other delimiter.";
```

Возможно вставлять выражение в строку используя `${выражение}`. Также можно вставлять идентификатор переменной, тогда {} можно опустить. Чтобы получить строку соответсвующую объекту можно вызвать метод `toString()`.

```dart
var s = 'интерполяция строк';

assert('В Dart есть $s, которая очень удобна.' ==
    'В Dart есть интерполяция строк, ' +
        'которая очень удобна.');
assert('${s.toUpperCase()} очень удобна!' ==
        'ИНТЕРПОЛЯЦИЯ СТРОК очень удобна!');
```

Сцепить строки можно при помощи оператора `+`:

```dart
var s1 = 'Оператор + ' + 'работает хорошо.';
var s2 = 'Конкатенация строк работает даже если'
    	  "строка разорвется.";
```

Для создание многострочной записи используются тройные одинарные или двойные ковычки:

```dart
var s1 = '''
Вы можете создать
многострочню запись вот так.
''';

var s2 = """Это также
многострочная запись.""";
```

Можно создать строку с игнорированием escape-последовательностей и спецсимволов:

```dart
var s = r'В raw-строке даже \n не получает особого отношения';
```

Строковой литерал является константой времени компиляции если он состоит также из выражений констант времени компиляции таких как null или числа, строки или логические переменные.

```dart
// Это работает в строковой константе
const aConstNum = 0;
const aConstBool = true;
const aConstString = 'строковая константа';

// Это работает в строковой константе
var aNum = 0;
var aBool = true;
var aString = 'строка';
const aConstList = [1, 2, 3];

const validConstString = '$aConstNum $aConstBool $aConstString';
// const invalidConstString = '$aNum $aBool $aString $aConstList';
```

#### Логический тип

Логический тип имеет только два объекта `true` и `false`, которые являются константами времени компиляции.

В Dart не возможно использовать не булево выражение в `if` или `assert`. Вместо этого нужно явно проверять значение переменной:

```dart
// Проверка пуста ли строка
var fullName = '';
assert(fullName.isEmpty);

// Проверка на ноль
var hitPoints = 0;
assert(hitPoints <= 0);

// Проверка на null
var unicorn;
assert(unicorn == null);

// Проверка на NaN.
var iMeantToDoThis = 0 / 0;
assert(iMeantToDoThis.isNaN);
```

#### Списки 

[List](https://api.dart.dev/stable/dart-core/List-class.html)

В Dart массивы - это объекты `List`.

```dart
var list = [1, 2, 3];
```

> **Примечание**: `list` имеет тип `List<int>`. Если попробовать добавить в этот список не целочисленно значение, то это приведет к ошибке.

Можно добавить запятую после последнего элемента списка. Эта запятая не будет влиять на всю коллекцию, но это поможет избежать ошибок копирования.

```dart
var list = [
  'Car',
  'Boat',
  'Plane',
];
```

Нумерация в списках начинается с нуля.

```dart
var list = [1, 2, 3];
assert(list.length == 3);
assert(list[1] == 2);

list[1] = 1;
assert(list[1] == 1);
```

Чтобы создать список, который является константой времени компиляции, нужно добавить `const` до списочного литерала:

```dart
var constantList = const [1, 2, 3];
// constantList[1] = 1; // This line will cause an error.
```

Dart 2.3 появиля spread-оператор (`...`) и spread-оператор с нулевым значением (`...?`), которые обеспечивают краткий способ вставки нескольких значений в коллекцию.

```dart
var list = [1, 2, 3];
var list2 = [0, ...list];
assert(list2.length == 4);
```

Если значение выражения справа от spread-оператора может быть null, то нужно использовать spread-оператор с нулевым значением (`...?`)

```dart
var list;
var list2 = [0, ...?list];
assert(list2.length == 1);
```

При создании списков можно использовать условные конструкции и циклы:

```dart
var nav = [
  'Home',
  'Furniture',
  'Plants',
  if (promoActive) 'Outlet'
];

var listOfInts = [1, 2, 3];
var listOfStrings = [
  '#0',
  for (var i in listOfInts) '#$i'
];
```

#### Наборы

[Set](https://api.dart.dev/stable/dart-core/Set-class.html)

Набор в Dart это неупорядоченная коллекция уникальных значений.

```dart
// halogens имеет тип Set<String>
var halogens = {'fluorine', 'chlorine', 'bromine', 'iodine', 'astatine'};
```

Для создания набора можно использовать пустую `{}`, которой предшевствует тип, или назначить `{}` переменной типа `Set`:

```dart
var names = <String>{};
Set<String> something = {}; 
// var names = {}; // компилятор не поймет какого типа набор
```

>  **Примечание**: Поскольку словари (`Map`) в Dart появились раньше наборов, то если забыть анотацию к `{}`, то для переменной создастся объект типа `Map<dynamic, dynamic>`

Для добавление элементов к существующему набору используются `add()` или `addAll()` методы:

```dart
var elements = <String>{};
elements.add('fluorine');
elements.addAll(halogens);
```

Для получения количества элементов в наборе используется `.length`:

```dart
assert(elements.length == 5);
```

Чтобы создать набор, который является константой времени компиляци, нужно добавлять `const` до установки литералов:

```dart
final constantSet = const {
  'fluorine',
  'chlorine',
  'bromine',
  'iodine',
  'astatine',
};
// constantSet.add('helium'); // Эта строка содержит ошибку.
```

Наборы также поддерживают spread-оператор (`...`), nullspread-operator (`...?`), условные конструкции (`if`) и циклы (`for`), также как и списки.

#### Словари

[Map](https://api.dart.dev/stable/dart-core/Map-class.html)

Словари состоят из ключей и значений. И ключи, и значения могут быть объектами любого типа. Ключ является уникальным, а значение может встречаться в словаре сколько угодно раз.

```dart
var gifts = {
  // Key:    Value
  'first': 'partridge',
  'second': 'turtledoves',
  'fifth': 'golden rings'
};

var nobleGases = {
  2: 'helium',
  10: 'neon',
  18: 'argon',
};
```

Словари можно создать и инициализировать по другому:

```dart
var gifts = Map();
gifts['first'] = 'partridge';
gifts['second'] = 'turtledoves';
gifts['fifth'] = 'golden rings';

var nobleGases = Map();
nobleGases[2] = 'helium';
nobleGases[10] = 'neon';
nobleGases[18] = 'argon';
```

> **Примечение**: словарь можно создать и так `new Map()`, но слово `new` в Dart не обязательно.

```dart
// инициализация словаря
var gifts = {'first': 'partridge'};
// добавление новой пары ключ-значение
gifts['fourth'] = 'calling birds'; 
// получение значения из словаря по ключу
assert(gifts['first'] == 'partridge');
// проверка имеется ли ключ в словаре
assert(gifts['fifth'] == null);
// количество пар в словаре
assert(gifts.length == 2);
```

Словарь можно создать как константу времени компиляции при помощи `const`:

```dart
final constantMap = const {
  2: 'helium',
  10: 'neon',
  18: 'argon',
};

// constantMap[2] = 'Helium'; // This line will cause an error.
```

Словари поддерживают spread-оператор (`...`), nullspread-operator (`...?`), условные конструкции (`if`) и циклы (`for`).

#### Руны и графемы

[Runes](https://api.dart.dev/stable/2.10.4/dart-core/Runes-class.html)

В Dart руны раскрывают кодовые точки Unicode строки.

Юникод определяет уникальное числовое значение для каждой буквы, цифры и символа, используемых во всех мировых системах письма. Поскольку строка Dart представляет собой последовательность кодовых единиц UTF-16, для выражения кодовых точек Unicode внутри строки требуется специальный синтаксис. Обычный способ обозначения кодовой точки Unicode - `\uXXXX`, где `XXXX` - 4-значное шестнадцатеричное значение. Например, символ сердца (`♥`) - `\u2665`. Чтобы указать более или менее 4 шестнадцатеричных цифр, заключите значение в фигурные скобки. Например, смеющийся смайлик (`😆`) - это `\u{1f606}`.

Если нужно прочитать или записать отдельные символы Unicode, нужно использовать метод получения символов, определенный в `String` пакет символов. Возвращенный объект `Characters` представляет собой строку как последовательность графем.

```dart
import 'package:characters/characters.dart';
...
var hi = 'Hi 🇩🇰';
print(hi);
print('The end of the string: ${hi.substring(hi.length - 1)}');
print('The last character: ${hi.characters.last}\n');
```

Результат:

```
$ dart bin/main.dart
Hi 🇩🇰
The end of the string: ???
The last character: 🇩🇰
```

#### Символы

[Symbol](https://api.dart.dev/stable/2.10.4/dart-core/Symbol-class.html)

Объект `Symbol` представляет собой оператор или идентификатор, объявленный в программе Dart. Возможно, вам никогда не понадобится использовать символы, но они бесценны для API, которые ссылаются на идентификаторы по имени, потому что минификация изменяет имена идентификаторов, но не символы идентификаторов.

Чтобы получить символ для идентификатора, используйте литерал символа, который представляет собой просто `#`, за которым следует идентификатор:

```dart
#radix
#bar
```

## Функции

Dart - настоящий объектно-ориентированный язык, поэтому даже функции являются объектами и имеют тип [Function](https://api.dart.dev/stable/dart-core/Function-class.html). Это означает, что функции могут быть присвоены переменным или переданы в качестве аргументов другим функциям. Можно вызвать экземпляр класса Dart, как если бы это была функция.

Вот пример реализации функции:

```dart
bool isNoble(int atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}
```

Хотя рекомендуется использовать аннотации типов для общедоступных API, функция по-прежнему работает, если вы опускаете типы

```dart
isNoble(atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}
```

Для функций, содержащих только одно выражение, можно использовать сокращенный синтаксис:

```dart
bool isNoble(int atomicNumber) => _nobleGases[atomicNumber] != null;
```

Синтаксис `=> expr` является сокращением для `{return expr; }`. Обозначение `=>` иногда называют синтаксисом *стрелки*.

> **Примечание**: Между стрелкой `=>` и точкой с запятой `;` может быть только выражение, но не оператор. Например, вы не можете поместить туда оператор `if`, но можете использовать условное выражение `expression ? true : false;`.

### Параметры

Функция может иметь любое количество требуемых *позиционных* параметров. За ними могут следовать *именованные* параметры или *необязательные* позиционные параметры (но не оба сразу).

> **Примечание**: Некоторые API - особенно конструкторы виджетов [Flutter](https://flutter.dev/) - используют только именованные параметры, даже если параметры являются обязательными. 

Можно использовать [конечные запятые](https://dart.dev/guides/language/language-tour#trailing-comma) при передаче аргументов функции или при определении параметров функции.

#### Именнованные параметры

Именованные параметры являются необязательными, если они специально не отмечены как обязательные. 

При вызове функции вы можете указать именованные параметры, используя `paramName: value`. Например:

```dart
enableFlags(bold: true, hidden: false);
```

При определении функции используйте `{param1, param2, …}`, чтобы указать именованные параметры:

```dart
/// Sets the [bold] and [hidden] flags ...
void enableFlags({bool bold, bool hidden}) {...}
```

Хотя именованные параметры являются своего рода необязательными параметрами, вы можете аннотировать их с помощью `@required`, чтобы указать, что параметр является обязательным - что пользователи должны указать значение для параметра. Например:

```dart
const Scrollbar({Key key, @required Widget child})
```

Если кто-то пытается создать `Scrollbar` без указания `child`, анализатор сообщает о проблеме.

Чтобы использовать аннотацию `@required`  необходимо импортировать пакет: `meta/meta.dart`.

#### Необязательные позиционные параметры

Заключение набора параметров функции в `[]` отмечает их как необязательные позиционные параметры:

```dart
String say(String from, String msg, [String device]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  return result;
}
```

Вот пример вызова этой функции без необязательного параметра:

```dart
assert(say('Bob', 'Howdy') == 'Bob says Howdy');
```

А вот пример вызова этой функции с третьим параметром:

```dart
assert(say('Bob', 'Howdy', 'smoke signal') ==
    'Bob says Howdy with a smoke signal');
```

#### Значения параметров по умолчанию

Функция может использовать `=` для определения значений по умолчанию как для именованных, так и для позиционных параметров. Значения по умолчанию должны быть константами времени компиляции. Если значение по умолчанию не указано, значение по умолчанию - `null`.

Вот пример установки значений по умолчанию для названных параметров:

```dart
/// Sets the [bold] and [hidden] flags ...
void enableFlags({bool bold = false, bool hidden = false}) {...}

// bold will be true; hidden will be false.
enableFlags(bold: true);
```

> **Примечание**: старый код может использовать двоеточие `:` вместо `=` для установки значений по умолчанию для именованных параметров. Причина в том, что изначально поддерживалось только `:` для именованных параметров. Эта поддержка может быть устаревшей, поэтому мы рекомендуем использовать `=` для указания значений по умолчанию.

В следующем примере показано, как установить значения по умолчанию для позиционных параметров:

```dart
String say(String from, String msg,
    [String device = 'carrier pigeon']) {
  var result = '$from says $msg with a $device';
  return result;
}

assert(say('Bob', 'Howdy') ==
    'Bob says Howdy with a carrier pigeon');
```

Можно передавать списки или словари в качестве значений по умолчанию. В следующем примере определяется функция `doStuff()`, которая определяет список по умолчанию для параметра `list` и словарь по умолчанию для параметра `gifts`.

```dart
void doStuff(
    {List<int> list = const [1, 2, 3],
    Map<String, String> gifts = const {
      'first': 'paper',
      'second': 'cotton',
      'third': 'leather'
    }}) {
  print('list:  $list');
  print('gifts: $gifts');
}
```

### Функция main()

аждое приложение должно иметь функцию верхнего уровня `main()`, которая служит точкой входа в приложение. 

Функция `main()` возвращает `void` и имеет необязательный параметр `List<String>` для аргументов.

Вот пример функции `main()` для веб-приложения:

```dart
void main() {
  querySelector('#sample_text_id')
    ..text = 'Click me!'
    ..onClick.listen(reverseText);
}
```

> **Примечание**: Синтаксис `..` в предыдущем коде называется каскадом. С помощью каскадов вы можете выполнять несколько операций с элементами одного объекта.

Вот пример функции `main()` для приложения командной строки, которое принимает аргументы:

```dart
// Run the app like this: dart args.dart 1 test
void main(List<String> arguments) {
  print(arguments);

  assert(arguments.length == 2);
  assert(int.parse(arguments[0]) == 1);
  assert(arguments[1] == 'test');
}
```

Можно использовать библиотеку [args](https://pub.dev/packages/args) для определения и анализа аргументов командной строки.

### Функции как объекты класса

Можно передать функцию в качестве параметра другой функции. Например:

```dart
void printElement(int element) {
  print(element);
}

var list = [1, 2, 3];

// Pass printElement as a parameter.
list.forEach(printElement);
```

Также можно присвоить переменной функцию, например:

```dart
var loudify = (msg) => '!!! ${msg.toUpperCase()} !!!';
assert(loudify('hello') == '!!! HELLO !!!');
```

В этом примере используется анонимная функция.

### Анонимные функции

Большинство функций имеют имена, например `main()` или `printElement()`. Также можно создать безымянную функцию, называемую *анонимной функцией*, или иногда *лямбда-выражением* или *замыканием*. Можно назначить анонимную функцию переменной, чтобы, например, добавить или удалить ее из коллекции.

Анонимная функция похожа на именованную функцию - ноль или более параметров, разделенных запятыми, и необязательные аннотации типов в круглых скобках.

Следующий блок кода содержит тело функции:

```
([[Type] param1[, …]]) {
  codeBlock;
};
```

В следующем примере определяется анонимная функция с нетипизированным параметром `item`. Функция, вызываемая для каждого элемента в списке, печатает строку, которая включает значение по указанному индексу.

```dart
var list = ['apples', 'bananas', 'oranges'];
list.forEach((item) {
  print('${list.indexOf(item)}: $item');
});
```

Если функция содержит только один оператор, можно сократить его, используя обозначения стрелок.

```dart
list.forEach(
    (item) => print('${list.indexOf(item)}: $item')
);
```

### Лексическая область видимости

Dart - это язык с лексической областью видимости. Это означает, что область видимости переменных определяется статически, просто компоновкой кода. Можно «проследить за фигурными скобками», чтобы увидеть, входит ли переменная в область видимости.

Вот пример вложенных функций с переменными на каждом уровне области видимости:

```dart
bool topLevel = true;

void main() {
  var insideMain = true;

  void myFunction() {
    var insideFunction = true;

    void nestedFunction() {
      var insideNestedFunction = true;

      assert(topLevel);
      assert(insideMain);
      assert(insideFunction);
      assert(insideNestedFunction);
    }
  }
}
```

### Лексические замыкания

*Замыкание* - это объект функции, который имеет доступ к переменным в своей лексической области видимости, даже если функция используется за пределами своей исходной области видимости.

Функции могут закрывать переменные, определенные в окружающих областях. В следующем примере `makeAdder()` захватывает переменную `addBy`. Куда бы ни отправилась возвращаемая функция, она запоминает `addBy`.

```dart
/// Returns a function that adds [addBy] to the
/// function's argument.
Function makeAdder(int addBy) {
  return (int i) => addBy + i;
}

void main() {
  // Create a function that adds 2.
  var add2 = makeAdder(2);

  // Create a function that adds 4.
  var add4 = makeAdder(4);

  assert(add2(3) == 5);
  assert(add4(3) == 7);
}
```

### Проверка функций на равенство

Вот пример тестирования функций верхнего уровня, статических методов и методов экземпляра на равенство:

```dart
void foo() {} // A top-level function

class A {
  static void bar() {} // A static method
  void baz() {} // An instance method
}

void main() {
  var x;

  // Comparing top-level functions.
  x = foo;
  assert(foo == x);

  // Comparing static methods.
  x = A.bar;
  assert(A.bar == x);

  // Comparing instance methods.
  var v = A(); // Instance #1 of A
  var w = A(); // Instance #2 of A
  var y = w;
  x = w.baz;

  // These closures refer to the same instance (#2),
  // so they're equal.
  assert(y.baz == x);

  // These closures refer to different instances,
  // so they're unequal.
  assert(v.baz != w.baz);
}
```

### Возвращаемые значения

Все функции возвращают значение. Если возвращаемое значение не указано, то оператор `return null;` неявно добавляется к телу функции.

```dart
foo() {}

assert(foo() == null);
```

## Операторы

Dart поддерживает операторы, указанные в следующей таблице. Операторы можно  реализовать как члены класса.

| Описание                   | Операторы                                                    |
| -------------------------- | ------------------------------------------------------------ |
| унарный постфикс           | `expr++`  `expr--`  `()`  `[]`  `.`  `?.`                    |
| унарный префикс            | `-expr`  `!expr`  `~expr`  `++expr`  `--expr`   `await expr` |
| мультипликативные          | `*`  `/`  `%` `~/`                                           |
| добавочные                 | `+`  `-`                                                     |
| сдвиг                      | `<<`  `>>`  `>>>`                                            |
| побитовое И                | `&`                                                          |
| побитовый XOR              | `^`                                                          |
| побитовое ИЛИ              | `|`                                                          |
| отношение и проверка  типа | `>=`  `>`  `<=`  `<`  `as`  `is`  `is!`                      |
| равенство                  | `==`  `!=`                                                   |
| логическое И               | `&&`                                                         |
| логическое ИЛИ             | `||`                                                         |
| проверка на null           | `??`                                                         |
| условный                   | `expr1 ? expr2 : expr3`                                      |
| каскад                     | `..`                                                         |
| присваивание               | `=`  `*=`  `/=`  `+=`  `-=`  `&=`  `^=`  *и т.д.*            |

> **Предупреждение**: приоритет оператора - это приблизительное поведение парсера Dart. Чтобы получить точные ответы, обратитесь к грамматике в [спецификации языка Dart](https://dart.dev/guides/language/spec).

Используя операторы, создаются выражения. Вот несколько примеров операторных выражений:

```dart
a++
a + b
a = b
a == b
c ? a : b
a is T
```

В таблице операторов каждый оператор имеет более высокий приоритет, чем операторы в следующих за ним строках. Например, мультипликативный оператор `%` имеет более высокий приоритет, чем (и, следовательно, выполняется раньше) оператор равенства `==`, который имеет более высокий приоритет, чем логический оператор И `&&`. Этот приоритет означает, что следующие две строки кода выполняются одинаково:

```dart
// Parentheses improve readability.
if ((n % i == 0) && (d % i == 0)) ...

// Harder to read, but equivalent.
if (n % i == 0 && d % i == 0) ...
```

> **Предупреждение**: для операторов, которые принимают два операнда, крайний левый операнд определяет, какой метод используется. Например, если у вас есть объект `Vector` и объект `Point`, то `aVector + aPoint` использует сложение `Vector` `+`.

### Арифметические операторы

Dart поддерживает обычные арифметические операторы, как показано в следующей таблице.

| Оператор | Значение                                                     |
| -------- | ------------------------------------------------------------ |
| `+`      | Сложение                                                     |
| `-`      | Вычитание                                                    |
| `-expr`  | Унарный минус, также известный как отрицание (поменять знак выражения) |
| `*`      | Умножение                                                    |
| `/`      | Деление                                                      |
| `~/`     | Деление нацело                                               |
| `%`      | Остаток от деления нацело                                    |

Примеры:

```dart
assert(2 + 3 == 5);
assert(2 - 3 == -1);
assert(2 * 3 == 6);
assert(5 / 2 == 2.5); // Result is a double
assert(5 ~/ 2 == 2); // Result is an int
assert(5 % 2 == 1); // Remainder

assert('5/2 = ${5 ~/ 2} r ${5 % 2}' == '5/2 = 2 r 1');
```

Dart также поддерживает как префиксные, так и постфиксные операторы увеличения и уменьшения.

| Оператор | Значение                                       |
| -------- | ---------------------------------------------- |
| `++var`  | `var = var + 1` (значение выражения `var + 1`) |
| `var++`  | `var = var + 1` (значение выражения `var`)     |
| `--var`  | `var = var - 1` (значение выражения `var - 1`) |
| `var--`  | `var = var - 1` (значение выражения `var`)     |

Примеры:

```dart
var a, b;

a = 0;
b = ++a; // Increment a before b gets its value.
assert(a == b); // 1 == 1

a = 0;
b = a++; // Increment a AFTER b gets its value.
assert(a != b); // 1 != 0

a = 0;
b = --a; // Decrement a before b gets its value.
assert(a == b); // -1 == -1

a = 0;
b = a--; // Decrement a AFTER b gets its value.
assert(a != b); // -1 != 0
```

### Операторы равенства и отношения

В следующей таблице перечислены значения операторов равенства и отношения.

| Оператор | Значение         |
| -------- | ---------------- |
| `==`     | равно            |
| `!=`     | не равно         |
| `>`      | больше           |
| `<`      | меньше           |
| `>=`     | больше или равно |
| `<=`     | меньше или равно |

Чтобы проверить, представляют ли два объекта `x` и `y` одно и то же, используйте оператор `==`. (В редком случае, когда вам нужно знать, являются ли два объекта одним и тем же объектом, используйте вместо этого функцию [identify ()](https://api.dart.dev/stable/dart-core/identical.html)) Вот как работает оператор `==`:

1. Если `x` или `y` равны `null`, вернуть истина, если оба равны `null`, и ложь, если только один из них равен `null`.
2. Вернуть результат вызова метода `x. == (y)`. (Такие операторы, как `==`, являются методами, которые вызываются для их первого операнда. )

### Операторы проверки типа

Операторы `as`, `is` и `is!` удобны для проверки типов во время выполнения.

| Оператор | Значение                                                     |
| -------- | ------------------------------------------------------------ |
| `as`     | Приведение типов (также используется для указания префиксов библиотеки) |
| `is`     | Истина, если объект имеет указанный тип                      |
| `is!`    | Ложь, если объект имеет указанный тип                        |

Результат `obj is T` истина, если `obj` реализует интерфейс, указанный в `T`. Например, `obj is Object` всегда истинно.

Используйте оператор `as` для приведения объекта к определенному типу тогда и только тогда, когда вы уверены, что объект относится к этому типу. Пример:

```dart
(emp as Person).firstName = 'Bob';
```

Если вы не уверены, что объект относится к типу `T`, используйте `is T` для проверки типа перед использованием объекта.

```dart
if (emp is Person) {
  // Type check
  emp.firstName = 'Bob';
}
```

> **Примечание**: Код не эквивалентен. Если `emp` имеет значение `null ` или не является `Person`, то в первом примере выдается исключение; второй ничего не сделает.

### Операторы присваивания

Значения можно присваивать с помощью оператора `=`.  Чтобы присвоить значение переменной только если она равноа `null` используется оператор `??=`.

```dart
// Assign value to a
a = value;
// Assign value to b if b is null; otherwise, b stays the same
b ??= value;
```

Операторы составного присваивания, такие как `+=`, объединяют операцию с присваиванием.

`=` `–=` `/=` `%=` `>>=` `^=` `+=` `*=` `~/=` `<<=` `&=` `|=`

Вот как работают составные операторы присваивания:

|                         | Составное присвиавание | Эквивалентное выражение |
| ----------------------- | ---------------------- | ----------------------- |
| **Для оператора *op*:** | `a op= b`              | `a = a op b`            |
| **Пример:**             | `a += b`               | `a = a + b`             |

В следующем примере используются операторы присваивания и составного присваивания:

```dart
var a = 2; // Assign using =
a *= 3; // Assign and multiply: a = a * 3
assert(a == 6);
```

### Логические операторы

Можно инвертировать или комбинировать логические выражения, используя логические операторы.

| Operator | Meaning                                                      |
| -------- | ------------------------------------------------------------ |
| `!expr`  | инвертирует следующее выражение (изменяет истина на ложь и наоборот) |
| `||`     | логическое И                                                 |
| `&&`     | логическое ИЛИ                                               |

Вот пример использования логических операторов:

```dart
if (!done && (col == 0 || col == 3)) {
  // ...Do something...
}
```

### Побитовые операторы и операторы сдвига

В Dart можно манипулировать отдельными битами чисел. Обычно эти побитовые операторы и операторы сдвига используются с целыми числами.

| Оператор | Значение                                                     |
| -------- | ------------------------------------------------------------ |
| `&`      | И                                                            |
| `|`      | ИЛИ                                                          |
| `^`      | Исключающее ИЛИ                                              |
| `~expr`  | Унарное побитовое дополнение (0s становится 1s; 1s становится 0s) |
| `<<`     | Сдвиг влево                                                  |
| `>>`     | Сдвиг вправо                                                 |

Вот пример использования побитовых операторов и операторов сдвига:

```dart
final value = 0x22;
final bitmask = 0x0f;

assert((value & bitmask) == 0x02); // AND
assert((value & ~bitmask) == 0x20); // AND NOT
assert((value | bitmask) == 0x2f); // OR
assert((value ^ bitmask) == 0x2d); // XOR
assert((value << 4) == 0x220); // Shift left
assert((value >> 4) == 0x02); // Shift right
```

### Условные выражения

В Dart есть два оператора, которые позволяют кратко оценивать выражения, которые в противном случае могли бы потребовать операторов `if-else`:

`condition ? expr1 : expr2`

Если `condition` истинно, вычисляет `expr1` (и возвращает его значение); в противном случае вычисляет и возвращает значение `expr2`.

`expr1 ?? expr2`

Если `expr1` не равно нулю, возвращает его значение; в противном случае вычисляет и возвращает значение `expr2`.

Если нужно присвоить значение на основе логического выражения используется `?:`.

```dart
var visibility = isPublic ? 'public' : 'private';
```

Если логическое выражение проверяется на `null`используется `??`.

```dart
// Slightly longer version uses ?: operator.
String playerName(String name) => name != null ? name : 'Guest';

// Very long version uses if-else statement.
String playerName(String name) {
  if (name != null) {
    return name;
  } else {
    return 'Guest';
  }
}
```

### Каскадная запись

Каскады `..` позволяют выполнять последовательность операций над одним и тем же объектом. Помимо вызовов функций, также можно получить доступ к полям того же объекта. Это часто избавляет от необходимости создавать временную переменную и позволяет писать более гибкий код.

Пример:

```dart
querySelector('#confirm') // Get an object.
  ..text = 'Confirm' // Use its members.
  ..classes.add('important')
  ..onClick.listen((e) => window.alert('Confirmed!'));
```

Первый вызов метода `querySelector()` возвращает объект селектора. Код, следующий за каскадной нотацией, работает с этим селекторным объектом, игнорируя любые последующие значения, которые могут быть возвращены.

Предыдущий пример эквивалентен:

```dart
var button = querySelector('#confirm');
button.text = 'Confirm';
button.classes.add('important');
button.onClick.listen((e) => window.alert('Confirmed!'));
```

Также можно вкладывать каскады. Например:

```dart
final addressBook = (AddressBookBuilder()
      ..name = 'jenny'
      ..email = 'jenny@example.com'
      ..phone = (PhoneNumberBuilder()
            ..number = '415-555-0100'
            ..label = 'home')
          .build())
    .build();
```

Нужно быть осторожным, создавая каскад на основе функции, возвращающей реальный объект. Например, следующий код не работает:

```dart
var sb = StringBuffer();
sb.write('foo')
  ..write('bar'); // Error: method 'write' isn't defined for 'void'.
```

Вызов `sb.write()` возвращает `void`, и не возможно построить каскад на `void`.

> **Примечание**: Обозначение каскадов «двойной точкой» не является оператором. Это просто часть синтаксиса Dart.

### Другие операторы

| Оператор | Название                | Значение                                                     |
| -------- | ----------------------- | ------------------------------------------------------------ |
| `()`     | Вызов функции           | Представляет вызов функции                                   |
| `[]`     | Доступ к списку         | Ссылается на значение по указанному индексу в списке         |
| `.`      | Доступ к члену          | Ссылается но свойство выражения; пример: `foo.bar` выбирает свойство `bar` из выражения `foo` |
| `?.`     | Условный доступ к члену | Как `.`, но крайний левый операнд может быть `null`; пример: `foo?.bar` ссылается на свойство  `bar` из выражения `foo` если только `foo` равна `null` (в этом случае значение `foo?.bar` равно `null`) |

## Операторы управления потоком

В Dart можно управлять потоком кода, используя любое из следующих действий:

- `if` и `else`
- цикл `for`
- циклы `while` и `do-while`
- `break` и `continue`
- `switch` и `case`
- `assert`

Также можно повлиять на поток управления с помощью `try-catch` и `throw`.

### If и else

Dart поддерживает операторы `if` с необязательными операторами `else`, как показано в следующем примере. 

```dart
if (isRaining()) {
  you.bringRainCoat();
} else if (isSnowing()) {
  you.wearJacket();
} else {
  car.putTopDown();
}
```

В отличие от JavaScript, условия должны использовать логические значения, ничего больше.

### Цикл for

Можно использовать стандартный цикл `for`. Например:

```dart
var message = StringBuffer('Dart is fun');
for (var i = 0; i < 5; i++) {
  message.write('!');
}
```

Замыкания внутри циклов `for` в Dart фиксируют значение индекса, избегая распространенной ошибки, обнаруживаемой в JavaScript. Например:

```dart
var callbacks = [];
for (var i = 0; i < 2; i++) {
  callbacks.add(() => print(i));
}
callbacks.forEach((c) => c());
```

Результатом будет `0`, а затем `1`, как и ожидалось. Напротив, в примере будет напечатано `2`, а затем `2` в JavaScript.

Если объект, который вы повторяете, является итерируемым, вы можете использовать метод `forEach()`. Использование `forEach()` - хороший вариант, если не нужно знать текущий счетчик итераций:

```dart
candidates.forEach((candidate) => candidate.interview());
```

Итерируемые классы, такие как `List` и `Set`, также поддерживают итерацию `for-in`:

```dart
var collection = [1, 2, 3];
for (var x in collection) {
  print(x); // 1 2 3
}
```

### While и do-while

Цикл `while` оценивает условие перед циклом:

```dart
while (!isDone()) {
  doSomething();
}
```

Цикл `do-while` оценивает условие после цикла:

```dart
do {
  printLine();
} while (!atEndOfPage());
```

### Break и continue

Чтобы остановить цикл нужно использовать `break`:

```dart
while (true) {
  if (shutDownRequested()) break;
  processIncomingRequests();
}
```

Чтобы перейти к следующей итерации цикла используется `continue`:

```dart
for (int i = 0; i < candidates.length; i++) {
  var candidate = candidates[i];
  if (candidate.yearsExperience < 5) {
    continue;
  }
  candidate.interview();
}
```

Можно написать этот пример по-другому, если использовать [Iterable](https://api.dart.dev/stable/dart-core/Iterable-class.html), например список или набор:

```dart
candidates
    .where((c) => c.yearsExperience >= 5)
    .forEach((c) => c.interview());
```

### Switch и case

Операторы `switch` в Dart сравнивают целочисленные, строковые или константы времени компиляции с помощью `==`. Все сравниваемые объекты должны быть экземплярами одного и того же класса (а не любого из его подтипов), и этот класс не должен переопределять `==`. Перечислимые типы хорошо работают в операторах `switch`.

> **Примечание**: операторы `switch` в Dart предназначены для ограниченных случаев, например, в интерпретаторах или сканерах.

Каждое непустое предложение `case`, как правило, заканчивается оператором `break`. Другими допустимыми способами завершения непустого предложения `case` являются операторы `continue`, `throw` или `return`.

Пункт `default` используется для выполнения кода, когда не подходит ни один из  `case`:

```dart
var command = 'OPEN';
switch (command) {
  case 'CLOSED':
    executeClosed();
    break;
  case 'PENDING':
    executePending();
    break;
  case 'APPROVED':
    executeApproved();
    break;
  case 'DENIED':
    executeDenied();
    break;
  case 'OPEN':
    executeOpen();
    break;
  default:
    executeUnknown();
}
```

В следующем примере оператор `break` отсутствует в пункте `case`, что приводит к ошибке:

```dart
var command = 'OPEN';
switch (command) {
  case 'OPEN':
    executeOpen();
    // ERROR: Missing break

  case 'CLOSED':
    executeClosed();
    break;
}
```

Тем не менее, Dart поддерживает пустые `case` о регистре, что позволяет избежать отказа:

```dart
var command = 'CLOSED';
switch (command) {
  case 'CLOSED': // Empty case falls through.
  case 'NOW_CLOSED':
    // Runs for both CLOSED and NOW_CLOSED.
    executeNowClosed();
    break;
}
```

Если действительно нужно провалиться дальше, то можно использовать оператор `continue` и метку:

```dart
var command = 'CLOSED';
switch (command) {
  case 'CLOSED':
    executeClosed();
    continue nowClosed;
  // Continues executing at the nowClosed label.

  nowClosed:
  case 'NOW_CLOSED':
    // Runs for both CLOSED and NOW_CLOSED.
    executeNowClosed();
    break;
}
```

Пункт `case` может иметь локальные переменные, которые видны только внутри области действия этого предложения.

### Assert

Во время разработки можно использовать оператор утверждения - `assert(condition, optionalMessage);` - чтобы прервать нормальное выполнение, если логическое условие ложно. В этом туре можно найти примеры утверждений. Вот еще несколько:

```dart
// Make sure the variable has a non-null value.
assert(text != null);

// Make sure the value is less than 100.
assert(number < 100);

// Make sure this is an https URL.
assert(urlString.startsWith('https'));
```

Чтобы прикрепить сообщение к утверждению, добавьте строку в качестве второго аргумента в `assert` (не обязательно с конечной запятой):

```dart
assert(urlString.startsWith('https'),
    'URL ($urlString) should start with "https".');
```

Первым аргументом assert может быть любое выражение, которое разрешается в логическое значение. Если значение выражения истинно, утверждение завершается успешно и выполнение продолжается. Если значение ложно, то утверждение не выполняется и выдается исключение ([AssertionError](https://api.dart.dev/stable/dart-core/AssertionError-class.html)).

Когда именно утверждения работают? Это зависит от инструментов и фреймворка, которые используются:

- Flutter включает утверждения в [режиме отладки](https://flutter.dev/docs/testing/debugging#debug-mode-assertions).
- Инструменты только для разработки, такие как [dartdevc](https://dart.dev/tools/dartdevc), обычно по умолчанию включают утверждения.
- Некоторые инструменты, такие как [dart](https://dart.dev/server/tools/dart-vm) и [dart2js](https://dart.dev/tools/dart2js), поддерживают утверждения с помощью флага командной строки: `--enable-asserts`.

В производственном коде утверждения игнорируются, а аргументы для `assert` не оцениваются.

## Исключения

